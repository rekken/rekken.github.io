<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-145401438-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <title>GeekPwn 2016 Windows 服务提权漏洞的分析和利用 | Yuebin Sun&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Yuebin Sun(@yuebinsun2020) 摘要GeekPwn 2016 比赛中有一道 Windows 服务漏洞提权题目，该服务程序会创建命名管道（Named Pipe）服务端接收客户端发送的文件路径然后调用 LoadLibrary 加载，但加载之前有一系列的检查过程，我们的最终目标是绕过这些检查，加载我们指定的 DLL并以 SYSTEM 权限执行任意代码。本文笔者逐一分析该服务的各个验">
<meta property="og:type" content="article">
<meta property="og:title" content="GeekPwn 2016 Windows 服务提权漏洞的分析和利用">
<meta property="og:url" content="https://rekken.github.io/2017/07/23/Analysis-and-Exploitation-of-GeekPwn-2016-Windows-Services-EoP-Vulnerability/index.html">
<meta property="og:site_name" content="Yuebin Sun&#39;s Blog">
<meta property="og:description" content="Yuebin Sun(@yuebinsun2020) 摘要GeekPwn 2016 比赛中有一道 Windows 服务漏洞提权题目，该服务程序会创建命名管道（Named Pipe）服务端接收客户端发送的文件路径然后调用 LoadLibrary 加载，但加载之前有一系列的检查过程，我们的最终目标是绕过这些检查，加载我们指定的 DLL并以 SYSTEM 权限执行任意代码。本文笔者逐一分析该服务的各个验">
<meta property="og:locale">
<meta property="og:image" content="https://rekken.github.io/2017/07/23/Analysis-and-Exploitation-of-GeekPwn-2016-Windows-Services-EoP-Vulnerability/geekpwn_image_1.png">
<meta property="og:image" content="https://rekken.github.io/2017/07/23/Analysis-and-Exploitation-of-GeekPwn-2016-Windows-Services-EoP-Vulnerability/geekpwn_image_2.png">
<meta property="og:image" content="https://rekken.github.io/2017/07/23/Analysis-and-Exploitation-of-GeekPwn-2016-Windows-Services-EoP-Vulnerability/geekpwn_image_3.png">
<meta property="og:image" content="https://rekken.github.io/2017/07/23/Analysis-and-Exploitation-of-GeekPwn-2016-Windows-Services-EoP-Vulnerability/geekpwn_image_4.png">
<meta property="og:image" content="https://rekken.github.io/2017/07/23/Analysis-and-Exploitation-of-GeekPwn-2016-Windows-Services-EoP-Vulnerability/geekpwn_image_5.png">
<meta property="article:published_time" content="2017-07-23T06:11:35.000Z">
<meta property="article:modified_time" content="2020-09-26T14:22:26.135Z">
<meta property="article:author" content="Yuebin Sun">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rekken.github.io/2017/07/23/Analysis-and-Exploitation-of-GeekPwn-2016-Windows-Services-EoP-Vulnerability/geekpwn_image_1.png">
<meta name="twitter:creator" content="@yuebinsun2020">
  
    <link rel="alternate" href="/atom.xml" title="Yuebin Sun&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Yuebin Sun&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://rekken.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Analysis-and-Exploitation-of-GeekPwn-2016-Windows-Services-EoP-Vulnerability" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/23/Analysis-and-Exploitation-of-GeekPwn-2016-Windows-Services-EoP-Vulnerability/" class="article-date">
  <time datetime="2017-07-23T06:11:35.000Z" itemprop="datePublished">2017-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      GeekPwn 2016 Windows 服务提权漏洞的分析和利用
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Yuebin Sun(<a target="_blank" rel="noopener" href="https://twitter.com/yuebinsun2020">@yuebinsun2020</a>)</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>GeekPwn 2016 比赛中有一道 Windows 服务漏洞提权题目，该服务程序会创建命名管道（Named Pipe）服务端接收客户端发送的文件路径然后调用 LoadLibrary 加载，但加载之前有一系列的检查过程，我们的最终目标是绕过这些检查，加载我们指定的 DLL并以 SYSTEM 权限执行任意代码。本文笔者逐一分析该服务的各个验证环节及其绕过方法，以及如何组合他们最终启动 SYSTEM 权限的计算器。</p>
<p>服务端的处理逻辑: </p>
<ol>
<li><p>服务端创建命名管道，等待客户端的连接。</p>
</li>
<li><p>客户端连接之后，服务端OpenProcess 打开客户端进程句柄，获得客户端进程 Image 文件路径。</p>
</li>
<li><p>验证客户端 Image 文件路径的签名。</p>
</li>
<li><p>签名验证通过之后，创建 Event 事件对象，无限等待 Event 对象直到 Signaled 状态。</p>
</li>
<li><p>通过管道接受客户端发送的 DLL 文件路径。</p>
</li>
<li><p>验证 DLL 文件路径的签名，签名通过之后调用 LoadLibrary 加载 DLL。</p>
</li>
</ol>
<a id="more"></a>

<h2 id="四个障碍"><a href="#四个障碍" class="headerlink" title="四个障碍"></a>四个障碍</h2><p>LoadLibrary 是我们的目标，但是在抵达目标之前，服务程序中有多层障碍需要绕过：</p>
<h3 id="1-管道创建时，没有赋予普通用户写权限。"><a href="#1-管道创建时，没有赋予普通用户写权限。" class="headerlink" title="1. 管道创建时，没有赋予普通用户写权限。"></a>1. 管道创建时，没有赋予普通用户写权限。</h3><p>管道创建时，指定的 DACL 字符串是 “D:(A;;GA;;;SY)(A;;GA;;;BA)(A;;GRWD;;;WD)”，普通用户没有向管道发送数据的权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">c:\project\geekpwn_2016&gt;accesschk.exe -v \pipe\GeekPwn2016</span><br><span class="line"></span><br><span class="line">\\.\Pipe\GeekPwn2016</span><br><span class="line">  Medium Mandatory Level (Default) [No-Write-Up]</span><br><span class="line">  RW NT AUTHORITY\SYSTEM</span><br><span class="line">        FILE_ALL_ACCESS</span><br><span class="line">  RW BUILTIN\Administrators</span><br><span class="line">        FILE_ALL_ACCESS</span><br><span class="line">  RW Everyone</span><br><span class="line">        FILE_LIST_DIRECTORY</span><br><span class="line">        FILE_READ_ATTRIBUTES</span><br><span class="line">        FILE_READ_DATA</span><br><span class="line">        FILE_READ_EA</span><br><span class="line">        SYNCHRONIZE</span><br><span class="line">        READ_CONTROL</span><br><span class="line">            WRITE_DAC</span><br></pre></td></tr></table></figure>

<h3 id="2-连接管道的客户端进程文件需携带有效签名。"><a href="#2-连接管道的客户端进程文件需携带有效签名。" class="headerlink" title="2. 连接管道的客户端进程文件需携带有效签名。"></a>2. 连接管道的客户端进程文件需携带有效签名。</h3><p>服务端接收客户端的连接请求之后，调用 OpenProcess 获得客户端进程句柄，然后得到客户端进程 Image 路径，之后会调用 WinVerifyTrust 验证签名。注意有些 PE 文件通过附属 Manifest 文件提供签名信息，而 WinVerifyTrust 验证签名时对这类文件会视为无效。只有签名验证通过之后才会继续下一步。</p>
<h3 id="3-客户端没有能力使服务端创建的-Event-对象置位（Signaled）。"><a href="#3-客户端没有能力使服务端创建的-Event-对象置位（Signaled）。" class="headerlink" title="3. 客户端没有能力使服务端创建的 Event 对象置位（Signaled）。"></a>3. 客户端没有能力使服务端创建的 Event 对象置位（Signaled）。</h3><p>服务端创建的 “Global\GeekPwn2016” Event 对象，客户端作为普通权限进程是没有权限调用 SetEvent 置为 Signaled 状态的。</p>
<h3 id="4-客户端发送给服务端的-DLL-路径需要通过签名验证后才能加载。"><a href="#4-客户端发送给服务端的-DLL-路径需要通过签名验证后才能加载。" class="headerlink" title="4. 客户端发送给服务端的 DLL 路径需要通过签名验证后才能加载。"></a>4. 客户端发送给服务端的 DLL 路径需要通过签名验证后才能加载。</h3><p>客户端通过管道发送的 DLL 路径会传递给 WinVerifyTrust 验证签名，验证通过后才会传递给 LoadLibrary 加载。</p>
<h2 id="Bypass-四个障碍"><a href="#Bypass-四个障碍" class="headerlink" title="Bypass 四个障碍"></a>Bypass 四个障碍</h2><h3 id="1-利用-WRITE-DAC-给普通用户添加管道写权限。"><a href="#1-利用-WRITE-DAC-给普通用户添加管道写权限。" class="headerlink" title="1. 利用 WRITE_DAC 给普通用户添加管道写权限。"></a>1. 利用 WRITE_DAC 给普通用户添加管道写权限。</h3><p>前面 accesschk 对管道权限的枚举结果可以发现，普通用户虽然没有 WRITE_DATA 权限，但也有不少权限，挨个查 MSDN，发现 WRITE_DAC 可以帮我们重新改写对象的 DACL 列表。</p>
<p>利用 WRITE_DAC 给 Everyone 组用户添加 WRITE_DATA 权限，网上可以找到代码片段，需要注意的是，调用 SetSecurityDescriptorDacl 之后，只是生成了一个新的满足需求的 SecurityDescriptor 对象，管道对象的 DACL 并没有被修改，需要进一步调用 SetKernelObjectSecurity 并传递 pipe handle 才能真正在管道对象中生效。</p>
<p>DACL 修改之后，还有个地方需要注意，管道对象的 handle 需要关闭且以 WRITE_DATA 权限再次打开才行，因为用于修改 DACL 的 handle 无论如何没有 WRITE_DATA 权限。</p>
<h3 id="2-向有签名的程序注入代码，借壳绕过-WinVerifyTrust-的签名检查。"><a href="#2-向有签名的程序注入代码，借壳绕过-WinVerifyTrust-的签名检查。" class="headerlink" title="2. 向有签名的程序注入代码，借壳绕过 WinVerifyTrust 的签名检查。"></a>2. 向有签名的程序注入代码，借壳绕过 WinVerifyTrust 的签名检查。</h3><img src="/2017/07/23/Analysis-and-Exploitation-of-GeekPwn-2016-Windows-Services-EoP-Vulnerability/geekpwn_image_1.png" class="" title="Image">

<p>服务端的检查代码如上图，先获得客户端进程 PE 文件路径，然后验证 PE 文件路径。所以如果我们可以找个有签名的程序，向其进程注入攻击代码就可以绕过上述检查了。</p>
<p>向有签名的程序注入代码有很多方法，最简单的是创建签名程序作为子进程，本例中笔者选用 SysInternals 工具集中的 procexp.exe，然后调用 WriteProcessMemory 和 CreateRemoteThread 注入代码。直接注入完整程序逻辑比较困难，所以我们注入的是一段加载用于加载 DLL 的 Shellcode，这段 Shellcode 运行时会加载同目录的 hello.dll，剩下的工作都在这个 hello.dll 中完成。</p>
<p>Hello.dll 中调用 CreateFile 和 CreateNamedPipeW 连接服务端管道时，服务端获得进程 PE 路径是 procexp.exe 的路径，WinVerifyTrust 验证签名有效。</p>
<h3 id="3-抢先创建-Event-对象，Event-Owner-就是自己了"><a href="#3-抢先创建-Event-对象，Event-Owner-就是自己了" class="headerlink" title="3. 抢先创建 Event 对象，Event Owner 就是自己了"></a>3. 抢先创建 Event 对象，Event Owner 就是自己了</h3><img src="/2017/07/23/Analysis-and-Exploitation-of-GeekPwn-2016-Windows-Services-EoP-Vulnerability/geekpwn_image_2.png" class="" title="Image">

<p>服务端创建并且无限期等待 Event 的代码如上图，服务端创建的 Event 普通权限的客户端进程显然是没有权限修改状态的。连接返回失败，GetLastError 返回错误代码 5，提示 Access Denied。想到一个方法是，在服务端创建 Global\GeekPwn2016 Event 之前，抢先创建同名 Event，并设置该 Event 的初始状态为 Signaled。根据 MSDN 中对 CreateEvent 返回值的描述，之后服务端进程调用 CreateEvent 创建时会返回我们之前创建的这个 Event 的句柄。再之后的 WaitForSingleObject() 会直接以成功状态返回（返回值为0）。</p>
<h3 id="4-LoadLibrary-的“灵活”与-WinVerifyTrust-的“死板”"><a href="#4-LoadLibrary-的“灵活”与-WinVerifyTrust-的“死板”" class="headerlink" title="4. LoadLibrary 的“灵活”与 WinVerifyTrust 的“死板”"></a>4. LoadLibrary 的“灵活”与 WinVerifyTrust 的“死板”</h3><img src="/2017/07/23/Analysis-and-Exploitation-of-GeekPwn-2016-Windows-Services-EoP-Vulnerability/geekpwn_image_3.png" class="" title="Image">

<p>服务端接收客户端发来的 DLL 路径后，验证过程如上图。还是调用 WinVerifyTrust 验证签名。这次怎么绕过签名检查呢？经过自己分析对比 LoadLibrary 和 WinVerifyTrust，发现二者在处理路径时存在标准不一致导致的漏洞。传递给 WinVerifyTrust 的路径，会当作全路径直接验证。而据 MSDN 介绍，LoadLibrary 似乎“灵活”很多，如果路径结尾没有扩展名，LoadLibrary 在真正的加载动作之前会自动补上一个 “.dll” 作为最终路径。</p>
<p>利用这个特性就可以绕过上面的检查了。假设我们传递的路径是 c:\test\evil。WinVerifyTrust 会直接验证 c:\test\evil。而 LoadLibrary 发现没有以 .dll 结尾，会自动追加，最终加载 c:\test\evil.dll。</p>
<p>注意，evil.dll 一定要编译成 64 位的，因为服务端主程序 GeekPwn2016.exe 是 64 位的。</p>
<p>成功迫使管道服务端加载 evil.dll 后启动 SYSTEM 权限计算器就很简单了，直接在 DLL Main 中调用 WinExec(“calc.exe”, SW_SHOW); 就好了，当然普通用户桌面中是看不到弹出计算器的，需要 procexp.exe 或者任务管理器查看。</p>
<img src="/2017/07/23/Analysis-and-Exploitation-of-GeekPwn-2016-Windows-Services-EoP-Vulnerability/geekpwn_image_4.png" class="" title="Image">

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次的服务端程序中，大部分漏洞或利用技巧都是依赖 MSDN 上一些不太显眼的特性或 Tricks。如果平时能够多收集这样的点，势必对漏洞的发现和利用大有帮助。</p>
<p>附录中会贴出精简后的服务端代码，完整的攻击程序源码会单独以压缩包形式提供。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><p>微软MSDN关于CreateEvent的文档： <a target="_blank" rel="noopener" href="https://msdn.microsoft.com/zh-cn/library/windows/desktop/ms682396(v=vs.85).aspx">https://msdn.microsoft.com/zh-cn/library/windows/desktop/ms682396(v=vs.85).aspx</a></p>
</li>
<li><p>微软 MSDN 关于 LoadLibrary 的文档： <a target="_blank" rel="noopener" href="https://msdn.microsoft.com/zh-cn/library/windows/desktop/ms684175(v=vs.85).aspx">https://msdn.microsoft.com/zh-cn/library/windows/desktop/ms684175(v=vs.85).aspx</a></p>
</li>
</ol>
<h2 id="附录-精简后的服务端代码"><a href="#附录-精简后的服务端代码" class="headerlink" title="附录 精简后的服务端代码"></a>附录 精简后的服务端代码</h2><img src="/2017/07/23/Analysis-and-Exploitation-of-GeekPwn-2016-Windows-Services-EoP-Vulnerability/geekpwn_image_5.png" class="" title="Image">


<p>rekken</p>
<p>2017.07.23</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rekken.github.io/2017/07/23/Analysis-and-Exploitation-of-GeekPwn-2016-Windows-Services-EoP-Vulnerability/" data-id="cker5305300029frkgze45d3e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/03/31/Analysis-of-Microsoft-Edge-Chakra-OP-NewScObjArray-Type-Confusion-Vulnerability/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Microsoft Edge Chakra OP_NewScObjArray 类型混淆漏洞分析笔记
        
      </div>
    </a>
  
  
    <a href="/2017/05/30/Windows-Logical-EoP-Workshop-Writeup/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Windows Logical EoP Workshop Writeup</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/macOS/" rel="tag">macOS</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/macOS/" style="font-size: 10px;">macOS</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/14/Security-Flaws-in-Adobe-Acrobat-Reader-Allow-Malicious-Program-to-Gain-Root-on-macOS-Silently/">Security Flaws in Adobe Acrobat Reader Allow Malicious Program to Gain Root on macOS Silently</a>
          </li>
        
          <li>
            <a href="/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-EN/">macOS Security Framework and previous CVEs</a>
          </li>
        
          <li>
            <a href="/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-CN/">macOS Security Framework and previous CVEs</a>
          </li>
        
          <li>
            <a href="/2019/03/31/Analysis-of-Microsoft-Edge-Chakra-OP-NewScObjArray-Type-Confusion-Vulnerability/">Microsoft Edge Chakra OP_NewScObjArray 类型混淆漏洞分析笔记</a>
          </li>
        
          <li>
            <a href="/2017/07/23/Analysis-and-Exploitation-of-GeekPwn-2016-Windows-Services-EoP-Vulnerability/">GeekPwn 2016 Windows 服务提权漏洞的分析和利用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Yuebin Sun<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>