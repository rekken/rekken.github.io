<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-145401438-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <title>macOS Security Framework and previous CVEs | Yuebin Sun&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Yuebin Sun(@yuebinsun) of Tencent Security Xuanwu Lab 摘要新冠病毒疫情出不了门，在家办公这两周笔者研究了一下 macOS 的 Security Framework。 本文主要分析 Security Framework 尤其是其中 Keychain 的架构，将 Security Framework 近一两年的历史漏洞做个整理。 Security">
<meta name="keywords" content="macOS">
<meta property="og:type" content="article">
<meta property="og:title" content="macOS Security Framework and previous CVEs">
<meta property="og:url" content="https://rekken.github.io/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-CN/index.html">
<meta property="og:site_name" content="Yuebin Sun&#39;s Blog">
<meta property="og:description" content="Yuebin Sun(@yuebinsun) of Tencent Security Xuanwu Lab 摘要新冠病毒疫情出不了门，在家办公这两周笔者研究了一下 macOS 的 Security Framework。 本文主要分析 Security Framework 尤其是其中 Keychain 的架构，将 Security Framework 近一两年的历史漏洞做个整理。 Security">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://rekken.github.io/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-CN/security-framework.png">
<meta property="og:image" content="https://rekken.github.io/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-CN/csda-of-macos.png">
<meta property="og:image" content="https://rekken.github.io/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-CN/keychain.png">
<meta property="og:image" content="https://rekken.github.io/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-CN/keychain-item-to-db.png">
<meta property="og:image" content="https://rekken.github.io/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-CN/secitemadd_to_xpc.png">
<meta property="og:image" content="https://rekken.github.io/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-CN/keychain_api_and_secd.jpg">
<meta property="og:image" content="https://rekken.github.io/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-CN/auth_security_agent.png">
<meta property="og:image" content="https://rekken.github.io/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-CN/securityd_securityagent.jpg">
<meta property="og:updated_time" content="2020-05-14T09:39:30.250Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="macOS Security Framework and previous CVEs">
<meta name="twitter:description" content="Yuebin Sun(@yuebinsun) of Tencent Security Xuanwu Lab 摘要新冠病毒疫情出不了门，在家办公这两周笔者研究了一下 macOS 的 Security Framework。 本文主要分析 Security Framework 尤其是其中 Keychain 的架构，将 Security Framework 近一两年的历史漏洞做个整理。 Security">
<meta name="twitter:image" content="https://rekken.github.io/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-CN/security-framework.png">
<meta name="twitter:creator" content="@yuebinsun">
  
    <link rel="alternate" href="/atom.xml" title="Yuebin Sun&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Yuebin Sun&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">The Road to 0x41414141</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://rekken.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-macOS-Security-Framework-and-Previous-CVEs-CN" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-CN/" class="article-date">
  <time datetime="2020-02-26T08:59:00.000Z" itemprop="datePublished">2020-02-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      macOS Security Framework and previous CVEs
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Yuebin Sun(@yuebinsun) of Tencent Security Xuanwu Lab</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>新冠病毒疫情出不了门，在家办公这两周笔者研究了一下 macOS 的 Security Framework。</p>
<p>本文主要分析 Security Framework 尤其是其中 Keychain 的架构，将 Security Framework 近一两年的历史漏洞做个整理。</p>
<h2 id="Security-Framework-简介"><a href="#Security-Framework-简介" class="headerlink" title="Security Framework 简介"></a>Security Framework 简介</h2><p>Security Framework 主要负责为 App 提供认证与授权、安全数据存储与传输（Keychain，App Transport Security）、代码签名、加密解密功能。</p>
<p>第三方 App 通过引用 Security Framework，使用 Apple 提供的 API 就可以直接使用这些功能，不用关心底层实现的细节。</p>
<img src="/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-CN/security-framework.png" title="Image">

<p>但 Security Framework 都有哪些组件，又是如何构建起来的呢？</p>
<a id="more"></a>

<p>官方最近已经不再更新整体的架构图了，在 [Mac OS X Internals] 书里找到了一张整体架构图，目前来看重要组件的变化不是特别大，可以用来参考</p>
<img src="/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-CN/csda-of-macos.png" title="Image">


<h2 id="Keychain"><a href="#Keychain" class="headerlink" title="Keychain"></a>Keychain</h2><p>Keychain 是 Security Framework 的重要组件，系统中保存的 WiFi 密码、Safari 保存的网站密码等都由 Keychain 组件负责管理。</p>
<p>Keychain 最早在 Mac OS 8.6 版本被引入，用于保存邮件系统（PowerTalk）的邮件服务器的登录凭据。现在的 Keychain 组件已经扩展了很多，可用于保存密码、加密密钥、证书以及 Notes，被 Apple 自身以及众多第三方应用使用。</p>
<img src="/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-CN/keychain.png" title="Image">

<p>iOS 与 macOS 系统中的 Keychain 略微有些差异，iOS 中只有一个 Keychain，设备解锁状态时 Keychain 可以访问，设备锁定状态时 Keychain 也处于锁定状态。macOS 则不同，macOS 系统允许用户自己创建任意的 Keychain 用于私有使用，Security Framework 提供了 SecKeychain{Create, Delete, Open，…} API 用于 macOS 用户管理 Keychain。</p>
<p>默认状态下，macOS 系统中存在两个 Keychain:</p>
<ul>
<li>~/Library/Keychains/login.keychain-db</li>
<li>/Library/Keychains/System.keychain</li>
</ul>
<p>其中 login Keychain 在 macOS 解锁状态时就会被解密，System.keychain 密钥保存在 /var/db/SystemKey，只有 root 用户可以访问。</p>
<p>具体目前系统中保存的 Keychain 以及存储的信息列表可以通过 macOS 的 Keychain Access.app 应用访问并查看。</p>
<h3 id="如何用-Keychain-存储一个网站密码"><a href="#如何用-Keychain-存储一个网站密码" class="headerlink" title="如何用 Keychain 存储一个网站密码"></a>如何用 Keychain 存储一个网站密码</h3><p>Apple 官网文档如下示例代码可以实现向 Kaychain 中存储一个网站的密码。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> let server = <span class="string">"www.example.com"</span></span><br><span class="line">let account = credentials.username</span><br><span class="line">let password = credentials.password.data(using: String.Encoding.utf8)!</span><br><span class="line">var query: [String: Any] = [kSecClass as String: kSecClassInternetPassword,</span><br><span class="line">                            kSecAttrAccount as String: account,</span><br><span class="line">                            kSecAttrServer as String: server,</span><br><span class="line">                            kSecValueData as String: password]</span><br><span class="line">let status = SecItemAdd(query as <span class="built_in">CFDictionary</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<p>其中核心的就是 SecItemAdd 这个 API，接下来我们将一步步分析这个 API 是如何实现的。</p>
<p>抽象的看，保存在 query 变量中的数据通过 SecItemAdd API 传递给 Keychain Service，服务进一步会将 query 数据封装为 Keychain Item，对于其中的 password 则会被加密，Keychain Item 进一步会被保存到磁盘的 Keychain Database。</p>
<img src="/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-CN/keychain-item-to-db.png" title="Image">


<p>如果从组件的角度看，SecItemAdd API 由 Security 共享库（Security Framework 的一部分，此处为了与 Security Framework 作区分所以叫共享库，/System/Library/Frameworks/Security.framework/Versions/A/Security）实现，Security 共享库会被加载进当前 App 进程，SecItemAdd API 收到数据后，进一步通过 SECURITYD_XPC 宏，将 API 调用转发至 com.apple.securityd.xpc XPC 服务，该服务位于 secd 进程，secd 以当前用户身份运行。</p>
<img src="/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-CN/secitemadd_to_xpc.png" title="Image">

<img src="/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-CN/keychain_api_and_secd.jpg" title="Image">

<p>进入 secd 进程之后，会根据 operation 进入到服务消息分发 handler（securityd_xpc_dictionary_handler）（代码已被精简）,对于 SecItemAdd，operation 为 sec_item_add_id，保存新增数据的 query 会被直接传递给 _SecItemAdd，除了 query 还有重要的数据结构 SecurityClient 结构体，SecurityClient 用于在后续的数据处理流程中支持访问控制检查，其中的 accessGroups 用于实现在 Web（Safari）和同一个团队开发的 App 之间共享密码，核心就是 Web 与 App 通过 Associated Domains Entitlement 关联，感兴趣可以参考 <a href="https://developer.apple.com/documentation/safariservices/supporting_associated_domains_in_your_app?language=objc" target="_blank" rel="noopener">Supporting Associated Domains in Your App</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">securityd_xpc_dictionary_handler</span><span class="params">(<span class="keyword">const</span> <span class="keyword">xpc_connection_t</span> connection, <span class="keyword">xpc_object_t</span> event)</span> </span>&#123;</span><br><span class="line">    SecurityClient client = &#123;</span><br><span class="line">        .task = <span class="literal">NULL</span>,</span><br><span class="line">        .accessGroups = <span class="literal">NULL</span>,</span><br><span class="line">        .musr = <span class="literal">NULL</span>,</span><br><span class="line">        .uid = xpc_connection_get_euid(connection),</span><br><span class="line">        .allowSystemKeychain = <span class="literal">false</span>,</span><br><span class="line">        .allowSyncBubbleKeychain = <span class="literal">false</span>,</span><br><span class="line">        .isNetworkExtension = <span class="literal">false</span>,</span><br><span class="line">        .canAccessNetworkExtensionAccessGroups = <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    fill_security_client(&amp;client, xpc_connection_get_euid(connection), auditToken));</span><br><span class="line">    <span class="keyword">switch</span> (operation)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> sec_item_add_id:</span><br><span class="line">        &#123;</span><br><span class="line">            _SecItemAdd(query, &amp;client, &amp;result, &amp;error) &amp;&amp; result);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>_SecItemAdd 内部就会将 query 数据转化为 Sqlite 的数据库增、删、改、查操作，最终实现对我们传递 query 的 item 插入操作。插入 sqlite3 的数据，password 会被加密。同时为了支持搜索，其他一些非私密数据会保持明文，这样可以支持对 keychain 数据库条目的搜索。至此 SecItemAdd API 新增网站密码的流程就结束了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> CFStringRef <span class="title">SecDbItemCopyInsertSQL</span><span class="params">(SecDbItemRef item, <span class="keyword">bool</span>(^use_attr)(<span class="keyword">const</span> SecDbAttr *attr))</span> </span>&#123;</span><br><span class="line">    CFMutableStringRef sql = CFStringCreateMutable(CFGetAllocator(item), <span class="number">0</span>);</span><br><span class="line">    CFStringAppend(sql, CFSTR(<span class="string">"INSERT INTO "</span>));</span><br><span class="line">    CFStringAppend(sql, item-&gt;class-&gt;name);</span><br><span class="line">    CFStringAppend(sql, CFSTR(<span class="string">"("</span>));</span><br><span class="line">    <span class="keyword">bool</span> needComma = <span class="literal">false</span>;</span><br><span class="line">    CFIndex used_attr = <span class="number">0</span>;</span><br><span class="line">    SecDbForEachAttr(item-&gt;class, attr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (use_attr(attr)) &#123;</span><br><span class="line">            ++used_attr;</span><br><span class="line">            SecDbAppendElement(sql, attr-&gt;name, &amp;needComma);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CFStringAppend(sql, CFSTR(<span class="string">")VALUES(?"</span>));</span><br><span class="line">    <span class="keyword">while</span> (used_attr-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        CFStringAppend(sql, CFSTR(<span class="string">",?"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    CFStringAppend(sql, CFSTR(<span class="string">")"</span>));</span><br><span class="line">    <span class="keyword">return</span> sql;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Safari 保存的这部分网站密码会被保存到 login keychain 数据库中，login keychain 等用户注销或者关机等操作时会被加密锁定。</p>
<h2 id="SecurityServer-与-SecurityAgent"><a href="#SecurityServer-与-SecurityAgent" class="headerlink" title="SecurityServer 与 SecurityAgent"></a>SecurityServer 与 SecurityAgent</h2><p>系统的 login Keychain 在系统处于解锁状态时就会自动解锁，所以上面保存网站密码时并没有涉及 keychain 的解密或解锁过程。</p>
<p>然而对于 System Keychain 或者时自己创建的 Keychain，这就涉及到 Keychain 数据库的加解锁、加解密处理，此时就需要 Security Server 的参与。</p>
<p>Security Server(/usr/sbin/securityd) 是一个 root 身份独立运行的 daemon 服务进程，如最上面的整体架构图所示，CDSA 架构中，Security Server 为 CDSA 架构提供了 CSP/DL Plugin，即负责数据的安全加密与存储。</p>
<p>Security Server 通过 ucsp MIG 接口提供服务，用于 client 访问 SecurityServer 内部对象。普通用户进程就可以访问此 MIG 接口。从源码中看这个服务提供了以下功能：</p>
<ul>
<li>管理请求 Security Server 的 clients（session、connection）</li>
<li>认证(Authentication)和授权(Authrization)的管理</li>
<li>Keychain 数据库的管理，包括锁定、解锁、数据加密、数据库的创建与修改</li>
<li>数据签名（Signature）的生成和验证</li>
<li>数据的加密和解密（ucsp_server_encrypt， ucsp_server_decrypt)</li>
<li>Key、key pair 的生成（ucsp_server_generateKey， ucsp_server_generateKeyPair、ucsp_server_wrapKey， ucsp_server_unwrapKey）</li>
<li>Code Signing Hosting(近几天公开的 10.15 版本源码中已经删除相关接口，暂未深入确认)</li>
</ul>
<p>可以看出 root 身份运行的 Security Server(securityd) 提供了很多高权限的敏感操作，同时也管理着大量敏感数据，因此如果可以发现这个服务进程的漏洞，那么影响也将非常大，KeySteal 就是利用该服务的漏洞实现无需密码验证访问 Keychain 保存的密码。</p>
<p>那么如何通过 MIG 接口与他交互呢？</p>
<p>在 Security 的源码中就包含了这个 ucsp MIG 接口的定义文件(OSX/libsecurityd/mig/ucsp.defs)。但很可惜，介绍 MIG 使用的文档很少，直接访问 Security Server 的文档更是没有。最终，我从 Linus Henze 写的 <a href="https://github.com/LinusHenze/Keysteal" target="_blank" rel="noopener">KeySteal Exploit</a> 代码中精简了一个访问 ucsp_server_setup 接口的 Client。</p>
<p>通过 mig 命令行工具生成 ucspUser.c 以及 ucspServer.c 接口定义源码，解决完编译依赖的头文件定义之后，就可以通过如下的示例测试代码访问 ucsp_server_setup 接口。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UCSP_ARGS    gServerPort, gReplyPort, &amp;securitydCreds, &amp;rcode</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATTRDATA(attr) (void *)(attr), (attr) ? strlen((attr)) : 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL(func) \</span></span><br><span class="line">    <span class="keyword">security_token_t</span> securitydCreds; \</span><br><span class="line">    CSSM_RETURN rcode; \</span><br><span class="line">    <span class="keyword">if</span> (KERN_SUCCESS != func) \</span><br><span class="line">        <span class="keyword">return</span> errSecCSInternalError; \</span><br><span class="line">    <span class="keyword">if</span> (securitydCreds.val[<span class="number">0</span>] != <span class="number">0</span>) \</span><br><span class="line">        <span class="keyword">return</span> CSSM_ERRCODE_VERIFICATION_FAILURE; \</span><br><span class="line">    <span class="keyword">return</span> rcode</span><br><span class="line"></span><br><span class="line">#define SSPROTOVERSION <span class="number">20000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mach_port_t</span> gServerPort;</span><br><span class="line"><span class="keyword">mach_port_t</span> gReplyPort;</span><br><span class="line"></span><br><span class="line"><span class="function">CSSM_RETURN <span class="title">securityd_setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;gReplyPort);</span><br><span class="line">    mach_port_insert_right(mach_task_self(), gReplyPort, gReplyPort, MACH_MSG_TYPE_MAKE_SEND);</span><br><span class="line">    bootstrap_look_up(bootstrap_port, (<span class="keyword">char</span>*)<span class="string">"com.apple.SecurityServer"</span>, &amp;gServerPort);</span><br><span class="line">    ClientSetupInfo info = &#123; <span class="number">0x1234</span>, SSPROTOVERSION &#125;;</span><br><span class="line">    CALL(ucsp_client_setup(UCSP_ARGS, mach_task_self(), info, <span class="string">"?:unspecified"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">mach_port_t</span> port;</span><br><span class="line">    <span class="keyword">mach_port_t</span> bootstrap_port;</span><br><span class="line">    task_get_bootstrap_port(mach_task_self(), &amp;bootstrap_port);</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr = bootstrap_look_up(bootstrap_port, <span class="string">"com.apple.SecurityServer"</span>, &amp;port);</span><br><span class="line">    securityd_setup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SecurityAgent"><a href="#SecurityAgent" class="headerlink" title="SecurityAgent"></a>SecurityAgent</h3><p>上面的介绍中提到，Security Server 还负责认证(Authentication)和授权(Authroization)。</p>
<img src="/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-CN/auth_security_agent.png" title="Image">

<p>当 Client 请求 Security Server 发起认证(Authentication)和授权(Authroization)验证时。如果需要与用户交互（输入密码）以验证身份，Security Server 就会通过 XPC 与 Security Agent（当前用户身份运行）通信，由 Security Agent 负责弹框与用户交互。用户输入的密码凭据信息由 Security Server 接收并管理，Client 只会收到验证或授权结果的消息。这个保证整个验证过程中 Client 不会接触密码等敏感信息，同时，这种机制也可以保证如果系统增加新的身份验证或鉴权扩展时，对 client 是透明的。</p>
<img src="/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-CN/securityd_securityagent.jpg" title="Image">


<h2 id="10-14-版本至今的历史漏洞分析"><a href="#10-14-版本至今的历史漏洞分析" class="headerlink" title="10.14 版本至今的历史漏洞分析"></a>10.14 版本至今的历史漏洞分析</h2><p>了解完了上面的一些必要的系统架构内容外，我们来继续看看 macOS 10.14 版本至今的涉及 Security 框架的漏洞，方便读者朋友了解漏洞的原理以及漏洞所在的组件。</p>
<p>需要说明的是，因为 Apple 官方在每次漏洞修复后并不会提供漏洞的详细信息，所以以下这些都是我根据源码自己分析整理的，这也意味着整理的结果可能不一定正确，如果您发现有错误或疏漏，请不吝指出。</p>
<h3 id="CVE-2019-8604（10-14-5-版本修复）"><a href="#CVE-2019-8604（10-14-5-版本修复）" class="headerlink" title="CVE-2019-8604（10.14.5 版本修复）"></a>CVE-2019-8604（10.14.5 版本修复）</h3><p>通过对比两个版本之间的源码，发现 CVE-2019-8604 漏洞的补丁。</p>
<p>这个漏洞在 securityd(Security Server Daemon) 中，securityd 提供的 MIG 接口在处理 client 端传递的 dbname 时，只有 assert 检查，而 assert 在 Release 版本是不存在的，因此，client 传递一个超长的字符串（长度超过 PATH_MAX)，ucsp_server_getDbName 接口就会触发 memcpy 内存越界拷贝。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- a/Security-58286.251.4/securityd/src/transition.cpp</span></span><br><span class="line"><span class="comment">+++ b/Security-58286.260.20/securityd/src/transition.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+static void checkPathLength(char const *str) &#123;</span></span><br><span class="line"><span class="addition">+    if (strlen(str) &gt;= PATH_MAX) &#123;</span></span><br><span class="line"><span class="addition">+        secerror("SecServer: path too long");</span></span><br><span class="line"><span class="addition">+        CssmError::throwMe(CSSMERR_CSSM_MEMORY_ERROR);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"></span><br><span class="line">@@ -306,15 +313,16 @@ kern_return_t ucsp_server_getDbName(UCSP_ARGS, DbHandle db, char name[PATH_MAX])</span><br><span class="line"> &#123;</span><br><span class="line">        BEGIN_IPC(getDbName)</span><br><span class="line">        string result = Server::database(db)-&gt;dbName();</span><br><span class="line"><span class="deletion">-       assert(result.length() &lt; PATH_MAX);</span></span><br><span class="line"><span class="addition">+       checkPathLength(result.c_str());</span></span><br><span class="line">        memcpy(name, result.c_str(), result.length() + 1);</span><br><span class="line"></span><br><span class="line">        END_IPC(DL)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> kern_return_t ucsp_server_setDbName(UCSP_ARGS, DbHandle db, const char *name)</span><br><span class="line"> &#123;</span><br><span class="line">        BEGIN_IPC(setDbName)</span><br><span class="line"><span class="addition">+       checkPathLength(name);</span></span><br><span class="line">        Server::database(db)-&gt;dbName(name);</span><br><span class="line">        END_IPC(DL)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>补丁中，在 ucsp_server_{get, set}DbName 中新增对路径名字的检查（checkPathLength），防止超长的 dbName 溢出固定长度（PATH_MAX）的 name。</p>
<p>因为 std::string 与 strlen 都会被且仅能被 “\0” 截断，所以 setDbName 与 getDbName 的处理方式就一致了。</p>
<h3 id="CVE-2019-8520-（10-14-4-版本修复）"><a href="#CVE-2019-8520-（10-14-4-版本修复）" class="headerlink" title="CVE-2019-8520 （10.14.4 版本修复）"></a>CVE-2019-8520 （10.14.4 版本修复）</h3><p>通过对比两个版本之间的源码，发现了 CVE-2019-8520 漏洞的补丁。</p>
<p>该漏洞位于 Security Server Daemon(securityd) 中，securityd（root） 负责处理系统中的管理系统中的 Authroization 和 Authentication，认证或者授权过程中，如果需要与用户交互（输入密码）以验证身份，securityd 就会通过 XPC 与 Security Agent（当前用户身份运行）通信，由 Security Agent 负责弹框与用户交互。</p>
<p>这个漏洞就出现在 securityd 与 Security Agent 的交互过程，securityd 在接收来自 Security Agent 的数据时，通过 XPC 传入 data，data 的长度为 length，另外通过另一个字段传入 sensitivelength，拷贝的时候，从 data 的起始位置拷贝长度为 sensitivelength 的内容到新创建的 dataCopy，因此，如果传入一个超长的 sensitivelength，超过上面传入的 data 的实际长度，将导致 data 的越界拷贝，会越界读取 data 变量之后的内存。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- a/Security-58286.240.4/securityd/src/agentquery.cpp</span></span><br><span class="line"><span class="comment">+++ b/Security-58286.251.4/securityd/src/agentquery.cpp</span></span><br><span class="line"></span><br><span class="line">static void xpcArrayToAuthItemSet(AuthItemSet *setToBuild, xpc_object_t input) &#123;</span><br><span class="line">    setToBuild-&gt;clear();</span><br><span class="line"></span><br><span class="line">    xpc_array_apply(input,  ^bool(size_t index, xpc_object_t item) &#123;</span><br><span class="line">        const char *name = xpc_dictionary_get_string(item, AUTH_XPC_ITEM_NAME);</span><br><span class="line"></span><br><span class="line">        size_t length;</span><br><span class="line">        const void *data = xpc_dictionary_get_data(item, AUTH_XPC_ITEM_VALUE, &amp;length);</span><br><span class="line">        void *dataCopy = 0;</span><br><span class="line"></span><br><span class="line">        // &lt;rdar://problem/13033889&gt; authd is holding on to multiple copies of my password in the clear</span><br><span class="line">        bool sensitive = xpc_dictionary_get_value(item, AUTH_XPC_ITEM_SENSITIVE_VALUE_LENGTH);</span><br><span class="line">        if (sensitive) &#123;</span><br><span class="line">            size_t sensitiveLength = (size_t)xpc_dictionary_get_uint64(item, AUTH_XPC_ITEM_SENSITIVE_VALUE_LENGTH);</span><br><span class="line"><span class="addition">+            if (sensitiveLength &gt; length) &#123;</span></span><br><span class="line"><span class="addition">+                secnotice("SecurityAgentXPCQuery", "Sensitive data len %zu is not valid", sensitiveLength);</span></span><br><span class="line"><span class="addition">+                return true;</span></span><br><span class="line"><span class="addition">+            &#125;</span></span><br><span class="line">            dataCopy = malloc(sensitiveLength);</span><br><span class="line">            memcpy(dataCopy, data, sensitiveLength);</span><br><span class="line">            memset_s((void *)data, length, 0, sensitiveLength); // clear the sensitive data, memset_s is never optimized away</span><br><span class="line">            length = sensitiveLength;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dataCopy = malloc(length);</span><br><span class="line">            memcpy(dataCopy, data, length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uint64_t flags = xpc_dictionary_get_uint64(item, AUTH_XPC_ITEM_FLAGS);</span><br><span class="line">        AuthItemRef nextItem(name, AuthValueOverlay((uint32_t)length, dataCopy), (uint32_t)flags);</span><br><span class="line">        setToBuild-&gt;insert(nextItem);</span><br><span class="line">        memset(dataCopy, 0, length); // The authorization items contain things like passwords, so wiping clean is important.</span><br><span class="line">        free(dataCopy);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>漏洞的修复逻辑就是加了一个对 sensitiveLength 的长度检查，保证 memcpy 的长度不超过 data。</p>
<h3 id="CVE-2019-8526（10-14-4-版本修复）"><a href="#CVE-2019-8526（10-14-4-版本修复）" class="headerlink" title="CVE-2019-8526（10.14.4 版本修复）"></a>CVE-2019-8526（10.14.4 版本修复）</h3><p>通过比对代码，发现了补丁。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">--- a/Security-58286.240.4/securityd/src/child.cpp</span></span><br><span class="line"><span class="comment">+++ b/Security-58286.251.4/securityd/src/child.cpp</span></span><br><span class="line">@@ -57,7 +57,7 @@ ServerChild::ServerChild()</span><br><span class="line"> //</span><br><span class="line"> ServerChild::~ServerChild()</span><br><span class="line"> &#123;</span><br><span class="line"><span class="deletion">-       mServicePort.destroy();</span></span><br><span class="line"><span class="addition">+       mServicePort.deallocate();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--- a/Security-58286.240.4/securityd/src/clientid.cpp</span></span><br><span class="line"><span class="comment">+++ b/Security-58286.251.4/securityd/src/clientid.cpp</span></span><br><span class="line">@@ -45,14 +45,18 @@ ClientIdentification::ClientIdentification()</span><br><span class="line"> // Initialize the ClientIdentification.</span><br><span class="line"> // This creates a process-level code object for the client.</span><br><span class="line"> //</span><br><span class="line"><span class="deletion">-void ClientIdentification::setup(pid_t pid)</span></span><br><span class="line"><span class="addition">+void ClientIdentification::setup(Security::CommonCriteria::AuditToken const &amp;audit)</span></span><br><span class="line"> &#123;</span><br><span class="line">     StLock&lt;Mutex&gt; _(mLock);</span><br><span class="line">     StLock&lt;Mutex&gt; __(mValidityCheckLock);</span><br><span class="line"><span class="deletion">-    OSStatus rc = SecCodeCreateWithPID(pid, kSecCSDefaultFlags, &amp;mClientProcess.aref());</span></span><br><span class="line"><span class="deletion">-       if (rc)</span></span><br><span class="line"><span class="deletion">-               secinfo("clientid", "could not get code for process %d: OSStatus=%d",</span></span><br><span class="line"><span class="deletion">-                       pid, int32_t(rc));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    audit_token_t const token = audit.auditToken();</span></span><br><span class="line"><span class="addition">+    OSStatus rc = SecCodeCreateWithAuditToken(&amp;token, kSecCSDefaultFlags, &amp;mClientProcess.aref());</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    if (rc) &#123;</span></span><br><span class="line"><span class="addition">+        secerror("could not get code for process %d: OSStatus=%d",</span></span><br><span class="line"><span class="addition">+                audit.pid(), int32_t(rc));</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">     mGuests.erase(mGuests.begin(), mGuests.end());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--- a/Security-58286.240.4/securityd/src/csproxy.cpp</span></span><br><span class="line"><span class="comment">+++ b/Security-58286.251.4/securityd/src/csproxy.cpp</span></span><br><span class="line">@@ -64,13 +64,12 @@ void CodeSigningHost::reset()</span><br><span class="line">        case noHosting:</span><br><span class="line">                break;  // nothing to do</span><br><span class="line">        case dynamicHosting:</span><br><span class="line"><span class="deletion">-               mHostingPort.destroy();</span></span><br><span class="line"><span class="deletion">-               mHostingPort = MACH_PORT_NULL;</span></span><br><span class="line"><span class="addition">+               mHostingPort.deallocate();</span></span><br><span class="line">         secnotice("SecServer", "%d host unregister", mHostingPort.port());</span><br><span class="line">                break;</span><br><span class="line">        case proxyHosting:</span><br><span class="line">                Server::active().remove(*this); // unhook service handler</span><br><span class="line"><span class="deletion">-               mHostingPort.destroy(); // destroy receive right</span></span><br><span class="line"><span class="addition">+               mHostingPort.modRefs(MACH_PORT_RIGHT_RECEIVE, -1);</span></span><br><span class="line">                mHostingState = noHosting;</span><br><span class="line">                mHostingPort = MACH_PORT_NULL;</span><br><span class="line">                mGuests.erase(mGuests.begin(), mGuests.end());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--- a/Security-58286.240.4/securityd/src/process.cpp</span></span><br><span class="line"><span class="comment">+++ b/Security-58286.251.4/securityd/src/process.cpp</span></span><br><span class="line"><span class="meta">@@ -40,7 +40,7 @@</span></span><br><span class="line"> // Construct a Process object.</span><br><span class="line"> //</span><br><span class="line"> Process::Process(TaskPort taskPort,    const ClientSetupInfo *info, const CommonCriteria::AuditToken &amp;audit)</span><br><span class="line"><span class="deletion">- :  mTaskPort(taskPort), mByteFlipped(false), mPid(audit.pid()), mUid(audit.euid()), mGid(audit.egid())</span></span><br><span class="line"><span class="addition">+ :  mTaskPort(taskPort), mByteFlipped(false), mPid(audit.pid()), mUid(audit.euid()), mGid(audit.egid()), mAudit(audit)</span></span><br><span class="line"> &#123;</span><br><span class="line">        StLock&lt;Mutex&gt; _(*this);</span><br><span class="line"></span><br><span class="line">@@ -48,6 +48,11 @@ Process::Process(TaskPort taskPort,  const ClientSetupInfo *info, const CommonCri</span><br><span class="line">        parent(Session::find(audit.sessionId(), true));</span><br><span class="line"></span><br><span class="line">        // let's take a look at our wannabe client...</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+       // Not enough to make sure we will get the right process, as</span></span><br><span class="line"><span class="addition">+       // pids get recycled. But we will later create the actual SecCode using</span></span><br><span class="line"><span class="addition">+       // the audit token, which is unique to the one instance of the process,</span></span><br><span class="line"><span class="addition">+       // so this just catches a pid mismatch early.</span></span><br><span class="line">        if (mTaskPort.pid() != mPid) &#123;</span><br><span class="line">                secnotice("SecServer", "Task/pid setup mismatch pid=%d task=%d(%d)",</span><br><span class="line">                                  mPid, mTaskPort.port(), mTaskPort.pid());</span><br><span class="line">@@ -55,7 +60,14 @@ Process::Process(TaskPort taskPort,  const ClientSetupInfo *info, const CommonCri</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setup(info);</span><br><span class="line"><span class="deletion">-       ClientIdentification::setup(this-&gt;pid());</span></span><br><span class="line"><span class="addition">+       ClientIdentification::setup(this-&gt;audit_token());</span></span><br></pre></td></tr></table></figure>

<p>这个漏洞正是之前读过 Paper 的 KeySteal 漏洞，补丁代码位于 securityd(Security Server Daemon) ，securityd 在通过 MIG 实现 Hosting Guest Code 机制时存在问题。</p>
<p>从补丁中可以看出漏洞存在的两个问题：</p>
<p>第一个是实现 Hosting Guest Code 机制，securityd 在创建 SecCode 时，错误地使用 SecCodeCreateWithPID 这个 API，这个 API 根据 pid 标识 Client Process，因此如补丁中的注释代码所说，存在 PID Reuse 的问题。</p>
<p>修复的方式是 SecCodeCreateWithPID 换做 SecCodeCreateWithAuditToken 用 audit token 表示 client。关于 PID 方式有何问题，可以参考之前 Samuel Groß 的 <a href="https://saelo.github.io/presentations/warcon18_dont_trust_the_pid.pdf" target="_blank" rel="noopener">《Don’t Trust the PID!》</a></p>
<p>第二个是 Mach Port 的引用计数问题，CodeSigningHost::reset() 调用 destory() 导致强制释放 Mach Port，被 destory 的 Mach Port 可能仍然被某些数据结构引用，同时因为用户态进程的 Mach Port 本身是 mach port name，其实就是个 number，既然是 number 就存在被 reuse 的可能。所以，在下次使用之前如果可以导致重新被占用，就可以实现 UAF。补丁修复也很容易，就是 destory 改为引用计数版本的 deallocate()。</p>
<h3 id="CVE-2018-4400（10-14-1-版本修复）"><a href="#CVE-2018-4400（10-14-1-版本修复）" class="headerlink" title="CVE-2018-4400（10.14.1 版本修复）"></a>CVE-2018-4400（10.14.1 版本修复）</h3><p>这个漏洞 Apple 公告中的描述是处理 S/MIME 消息时拒绝服务，对比代码，得到的了疑似补丁，不敢完全确定</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- a/Security-58286.200.222/OSX/libsecurity_smime/lib/smimeutil.c</span></span><br><span class="line"><span class="comment">+++ b/Security-58286.220.15/OSX/libsecurity_smime/lib/smimeutil.c</span></span><br><span class="line">@@ -733,6 +733,8 @@ SecSMIMEGetCertFromEncryptionKeyPreference(SecKeychainRef keychainOrArray, CSSM_</span><br><span class="line">        cert = CERT_FindCertByIssuerAndSN(keychainOrArray, rawCerts, NULL, tmppoolp, ekp.id.issuerAndSN);</span><br><span class="line">        break;</span><br><span class="line">     case NSSSMIMEEncryptionKeyPref_RKeyID:</span><br><span class="line"><span class="addition">+        cert = CERT_FindCertBySubjectKeyID(keychainOrArray, rawCerts, NULL, &amp;ekp.id.recipientKeyID-&gt;subjectKeyIdentifier);</span></span><br><span class="line"><span class="addition">+        break;</span></span><br><span class="line">     case NSSSMIMEEncryptionKeyPref_SubjectKeyID:</span><br><span class="line">         cert = CERT_FindCertBySubjectKeyID(keychainOrArray, rawCerts, NULL, ekp.id.subjectKeyID);</span><br><span class="line">        break;</span><br></pre></td></tr></table></figure>

<p>对证书管理及相关的数据结构暂时还不太熟悉，暂时不进一步分析了</p>
<p>上面这些是目前我找到的比较确定的一些漏洞及其补丁，因为 Apple 开源代码非常滞后，所以上面这些主要是 10.14.* 版本中涉及 Security Framework 的漏洞的分析。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我这段时间研究 Security Framework 并做的分享。因为 Security Framework 比较庞大，我只重点介绍了 Keychain 以及历史上被发现漏洞比较多的 Security Server 组件。其他像 Auth 组件来得及分析，等后续对这些组件有了新的研究，我将继续分享。</p>
<p>如果发现上面的内容有错误，或者您也对 macOS 感兴趣，欢迎联系我 <a href="https://twitter.com/yuebinsun" target="_blank" rel="noopener">@yuebinsun</a>。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] Documentation of Security Framework</p>
<p><a href="https://developer.apple.com/documentation/security?language=objc" target="_blank" rel="noopener">https://developer.apple.com/documentation/security?language=objc</a></p>
<p>[2] Apple Open Source Code</p>
<p><a href="https://opensource.apple.com/" target="_blank" rel="noopener">https://opensource.apple.com/</a></p>
<p>[3] KeySteal Vulnerability</p>
<p><a href="https://www.pinauten.de/resources/KeySteal_OBTS_2019.pdf" target="_blank" rel="noopener">https://www.pinauten.de/resources/KeySteal_OBTS_2019.pdf</a></p>
<p>[4] Keychain Wikipedia</p>
<p><a href="https://en.wikipedia.org/wiki/Keychain_(software)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Keychain_(software)</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rekken.github.io/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-CN/" data-id="cka6wq8430007qvrkpfmz8gvu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/macOS/">macOS</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-EN/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          macOS Security Framework and previous CVEs
        
      </div>
    </a>
  
  
    <a href="/2019/03/31/Analysis-of-Microsoft-Edge-Chakra-OP-NewScObjArray-Type-Confusion-Vulnerability/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Microsoft Edge Chakra OP_NewScObjArray 类型混淆漏洞分析笔记</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/macOS/">macOS</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/macOS/" style="font-size: 10px;">macOS</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/14/Security-Flaws-in-Adobe-Acrobat-Reader-Allow-Malicious-Program-to-Gain-Root-on-macOS-Silently/">Security Flaws in Adobe Acrobat Reader Allow Malicious Program to Gain Root on macOS Silently</a>
          </li>
        
          <li>
            <a href="/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-EN/">macOS Security Framework and previous CVEs</a>
          </li>
        
          <li>
            <a href="/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-CN/">macOS Security Framework and previous CVEs</a>
          </li>
        
          <li>
            <a href="/2019/03/31/Analysis-of-Microsoft-Edge-Chakra-OP-NewScObjArray-Type-Confusion-Vulnerability/">Microsoft Edge Chakra OP_NewScObjArray 类型混淆漏洞分析笔记</a>
          </li>
        
          <li>
            <a href="/2017/07/23/Analysis-and-Exploitation-of-GeekPwn-2016-Windows-Services-EoP-Vulnerability/">GeekPwn 2016 Windows 服务提权漏洞的分析和利用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 rekken<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>