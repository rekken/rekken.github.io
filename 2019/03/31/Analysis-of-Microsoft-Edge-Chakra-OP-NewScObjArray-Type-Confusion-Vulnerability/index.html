<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Microsoft Edge Chakra OP_NewScObjArray 类型混淆漏洞分析笔记 | The Road to 0x41414141</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1 环境信息 Windows 10 X64 14393 (1607) - 没有安装过任何补丁 Microsoft Edge 38.14393.0.0 Microsoft EdgeHTML 14.14393  2 Crash Point12345678910111213141516171819202122232425262728293031323334(1648.f78): Access viola">
<meta property="og:type" content="article">
<meta property="og:title" content="Microsoft Edge Chakra OP_NewScObjArray 类型混淆漏洞分析笔记">
<meta property="og:url" content="https://rekken.github.io/2019/03/31/Analysis-of-Microsoft-Edge-Chakra-OP-NewScObjArray-Type-Confusion-Vulnerability/index.html">
<meta property="og:site_name" content="The Road to 0x41414141">
<meta property="og:description" content="1 环境信息 Windows 10 X64 14393 (1607) - 没有安装过任何补丁 Microsoft Edge 38.14393.0.0 Microsoft EdgeHTML 14.14393  2 Crash Point12345678910111213141516171819202122232425262728293031323334(1648.f78): Access viola">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-08-03T09:14:12.230Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Microsoft Edge Chakra OP_NewScObjArray 类型混淆漏洞分析笔记">
<meta name="twitter:description" content="1 环境信息 Windows 10 X64 14393 (1607) - 没有安装过任何补丁 Microsoft Edge 38.14393.0.0 Microsoft EdgeHTML 14.14393  2 Crash Point12345678910111213141516171819202122232425262728293031323334(1648.f78): Access viola">
  
    <link rel="alternate" href="/atom.xml" title="The Road to 0x41414141" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">The Road to 0x41414141</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://rekken.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Analysis-of-Microsoft-Edge-Chakra-OP-NewScObjArray-Type-Confusion-Vulnerability" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/31/Analysis-of-Microsoft-Edge-Chakra-OP-NewScObjArray-Type-Confusion-Vulnerability/" class="article-date">
  <time datetime="2019-03-31T09:06:11.000Z" itemprop="datePublished">2019-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Microsoft Edge Chakra OP_NewScObjArray 类型混淆漏洞分析笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-环境信息"><a href="#1-环境信息" class="headerlink" title="1 环境信息"></a>1 环境信息</h2><ul>
<li>Windows 10 X64 14393 (1607) - 没有安装过任何补丁</li>
<li>Microsoft Edge 38.14393.0.0</li>
<li>Microsoft EdgeHTML 14.14393</li>
</ul>
<h2 id="2-Crash-Point"><a href="#2-Crash-Point" class="headerlink" title="2 Crash Point"></a>2 Crash Point</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(1648.f78): Access violation - code c0000005 (first chance)</span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected and handled.</span><br><span class="line">chakra!Js::DynamicProfileInfo::RecordCallSiteInfo+0x75:</span><br><span class="line">00007ff9`dc43d0c5 66418500        test    word ptr [r8],ax ds:000001e5`b6a4f048=????</span><br><span class="line">0:010&gt; kb</span><br><span class="line"> # RetAddr           : Args to Child                                                           : Call Site</span><br><span class="line">00 00007ff9`dc23d3ea : 000001e5`b6950020 000001e5`d56f01a0 00000000`0000fefa 00007ff9`dc9583c8 : chakra!Js::DynamicProfileInfo::RecordCallSiteInfo+0x75</span><br><span class="line">01 00007ff9`dc23def7 : 000001e5`b8ff97c0 0000004a`3a3fb100 000001e5`d0f407e0 00007ff9`dc37fefa : chakra!Js::ProfilingHelpers::ProfiledNewScObjArray+0x9e</span><br><span class="line">02 00007ff9`dc38d74a : 0000004a`3a3fb410 000001e5`d6f3dc64 000001e5`b7bfa760 00007ff9`dc374943 : chakra!Js::InterpreterStackFrame::OP_NewScObjArray_Impl&lt;Js::OpLayoutT_CallI&lt;Js::LayoutSizePolicy&lt;1&gt; &gt;,0&gt;+0x8f</span><br><span class="line">03 00007ff9`dc374cdd : 0000004a`3a3fb1e8 000001e5`d6f3dc63 000001e5`d6f3dc5f 00000000`00000000 : chakra!Js::JavascriptRegExpConstructor::GetPropertyBuiltIns+0xd22</span><br><span class="line">04 00007ff9`dc374b07 : 0000004a`3a3fb410 00000000`00000000 00000000`00000001 00000000`00000000 : chakra!Js::InterpreterStackFrame::ProcessUnprofiled+0xbd</span><br><span class="line">05 00007ff9`dc3736c9 : 0000004a`3a3fb410 0000004a`3a3fb410 0000004a`3a3fb410 00000000`00000001 : chakra!Js::InterpreterStackFrame::Process+0x1a7</span><br><span class="line">06 00007ff9`dc375a04 : 0000004a`3a3fb410 000001e5`d6f3dc47 000001e5`d6f3dc47 00000000`00000000 : chakra!Js::InterpreterStackFrame::OP_TryCatch+0x61</span><br><span class="line">07 00007ff9`dc374b07 : 0000004a`3a3fb410 00000000`00000000 00000000`00000000 00000000`00000000 : chakra!Js::InterpreterStackFrame::ProcessUnprofiled+0xde4</span><br><span class="line">08 00007ff9`dc378b5e : 0000004a`3a3fb410 000001e5`d56f01a0 0000004a`3a3fbd80 00007ff9`e46a3f00 : chakra!Js::InterpreterStackFrame::Process+0x1a7</span><br><span class="line">09 00007ff9`dc37a265 : 000001e5`d0f407e0 0000004a`3a3fbf50 000001e5`b65b0fba 0000004a`3a3fbf68 : chakra!Js::InterpreterStackFrame::InterpreterHelper+0x48e</span><br><span class="line">0a 000001e5`b65b0fba : 0000004a`3a3fbfa0 00000000`00000001 0000004a`3a3fc378 00007ff9`dc4a0fe0 : chakra!Js::InterpreterStackFrame::InterpreterThunk+0x55</span><br><span class="line">0b 00007ff9`dc4a1393 : 000001e5`d0f407e0 00000000`10000001 000001e5`ce93ff90 00000000`00000001 : 0x000001e5`b65b0fba</span><br><span class="line">0c 00007ff9`dc36ef6d : 000001dd`a72844f0 00000000`00000008 000001e5`d0300110 0000004a`3a3fc001 : chakra!amd64_CallFunction+0x93</span><br><span class="line">0d 00007ff9`dc372797 : 0000004a`3a3fc230 000001e5`d5874036 000001e5`d0f407e0 000001e5`00000001 : chakra!Js::InterpreterStackFrame::OP_CallCommon&lt;Js::OpLayoutDynamicProfile&lt;Js::OpLayoutT_CallIWithICIndex&lt;Js::LayoutSizePolicy&lt;0&gt; &gt; &gt; &gt;+0x15d</span><br><span class="line">0e 00007ff9`dc376842 : 0000004a`3a3fc230 000001e5`d5874036 000001e5`00000119 00000000`00000000 : chakra!Js::InterpreterStackFrame::OP_ProfiledCallIWithICIndex&lt;Js::OpLayoutT_CallIWithICIndex&lt;Js::LayoutSizePolicy&lt;0&gt; &gt; &gt;+0xa7</span><br><span class="line">0f 00007ff9`dc374aa2 : 0000004a`3a3fc230 00000000`00000000 00000000`00000000 00000000`00000000 : chakra!Js::InterpreterStackFrame::ProcessProfiled+0x132</span><br><span class="line">10 00007ff9`dc378b5e : 0000004a`3a3fc230 000001e5`d56f0000 0000004a`3a3fc390 ffffffff`ffffff01 : chakra!Js::InterpreterStackFrame::Process+0x142</span><br><span class="line">11 00007ff9`dc37a265 : 000001e5`d0f40900 0000004a`3a3fc560 000001e5`b65b0fc2 0000004a`3a3fc578 : chakra!Js::InterpreterStackFrame::InterpreterHelper+0x48e</span><br><span class="line">12 000001e5`b65b0fc2 : 0000004a`3a3fc5b0 00000000`00000000 00000000`00000000 00007ff9`dc4a0fe0 : chakra!Js::InterpreterStackFrame::InterpreterThunk+0x55</span><br><span class="line">13 00007ff9`dc4a1393 : 000001e5`d0f40900 00000000`00000000 00000000`00000000 00000000`00000000 : 0x000001e5`b65b0fc2</span><br><span class="line">14 00007ff9`dc36d873 : 000001dd`a72844f0 00000000`00000000 000001e5`d0316f00 00007ff9`dc3d2f87 : chakra!amd64_CallFunction+0x93</span><br><span class="line">15 00007ff9`dc3dc2ec : 000001e5`d0f40900 00007ff9`dc4a15a0 0000004a`3a3fc6c0 000001e5`d030e6d0 : chakra!Js::JavascriptFunction::CallFunction&lt;1&gt;+0x83</span><br><span class="line">16 00007ff9`dc3db8b6 : 000001e5`d0f40900 0000004a`3a3fc7a0 000001e5`d030e6d0 0000004a`3a3fc700 : chakra!Js::JavascriptFunction::CallRootFunctionInternal+0x104</span><br><span class="line">17 00007ff9`dc486259 : 000001e5`d0f40900 0000004a`3a3fc840 000001e5`d030e6d0 00000000`00000000 : chakra!Js::JavascriptFunction::CallRootFunction+0x4a</span><br><span class="line">18 00007ff9`dc3e1d41 : 000001e5`d0f40900 0000004a`3a3fc8a0 00000000`00000000 0000004a`3a3fc880 : chakra!ScriptSite::CallRootFunction+0xb5</span><br><span class="line">19 00007ff9`dc392a1d : 000001e5`d030cf00 000001e5`d0f40900 0000004a`3a3fc950 00000000`00000000 : chakra!ScriptSite::Execute+0x131</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="3-找到存在该漏洞的-Chakracore-版本源码进行源码调试"><a href="#3-找到存在该漏洞的-Chakracore-版本源码进行源码调试" class="headerlink" title="3 找到存在该漏洞的 Chakracore 版本源码进行源码调试"></a>3 找到存在该漏洞的 Chakracore 版本源码进行源码调试</h2><p>既然当前 Windows 版本（1607）可以触发崩溃，那我们就下载该版本对应的 ChakraCore 源码。</p>
<p>Windows 10 1607 的发布时间是 2016/08/02，我们从 GitHub ChakraCore 的 <a href="https://github.com/Microsoft/ChakraCore/wiki/Roadmap" target="_blank" rel="noopener">Roadmap</a> 上找一个大概 8 月份的源码版本：<br><a href="https://github.com/Microsoft/ChakraCore/releases/tag/v1.2.0.0" target="_blank" rel="noopener">https://github.com/Microsoft/ChakraCore/releases/tag/v1.2.0.0</a></p>
<p>下载其中的 ChakraCore-binaries.zip 二进制文件和 Source code(zip) 源码。</p>
<p>下载后用 ChakraCore-binaries 中的 x64\ch.exe 直接运行 poc.js（去掉其中的 alert 等非 JS 引擎内置函数），测试效果，可以看到 ch.exe 也崩溃了，而且错误代码也是 0xc000005，这也说明：</p>
<ul>
<li>漏洞在该 Chakracore 版本上确实存在。</li>
<li>漏洞的触发只与 ChakraCore JavaScript 引擎有关。</li>
</ul>
<p>所以我们完全可以不调试浏览器而只调试 ch.exe 来研究该漏洞，只调试 ch.exe 相对容易而且可以下载并编译源码调试。</p>
<h2 id="4-调试分析"><a href="#4-调试分析" class="headerlink" title="4 调试分析"></a>4 调试分析</h2><p>从崩溃点的调用栈 OP_NewScObjArray_Impl 函数可以判断，崩溃发生在 OP_NewScObjArray OpCode 的处理过程中。所以很自然地就想到要为 OP_NewScObjArray 处理过程下断点跟踪调试。</p>
<h3 id="4-1-应该在哪里设置断点"><a href="#4-1-应该在哪里设置断点" class="headerlink" title="4.1 应该在哪里设置断点"></a>4.1 应该在哪里设置断点</h3><p>Interpreter 模式执行时， Js::InterpreterStackFrame::INTERPRETERLOOPNAME() 内部，OpCode 被 Interpreter 逐一 Read 然后解释执行。</p>
<p>所以如果想为某个特定的 OpCode 下断点，可以先在 Js::InterpreterStackFrame::INTERPRETERLOOPNAME() 内部下断点</p>
<h3 id="4-2-为-NewScObjArray-的-OpCode-设置断点"><a href="#4-2-为-NewScObjArray-的-OpCode-设置断点" class="headerlink" title="4.2 为 NewScObjArray 的 OpCode 设置断点"></a>4.2 为 NewScObjArray 的 OpCode 设置断点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; bp ch!runscript</span><br><span class="line">0:000&gt; g</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">CH!RunScript:</span><br><span class="line">00007ff7`890c5e90 4c894c2420      mov     qword ptr [rsp+20h],r9 ss:000000f1`528ff658=000000f1528ff6c8</span><br><span class="line">0:004&gt; bp chakracore!Js::InterpreterStackFrame::ProcessUnprofiled</span><br></pre></td></tr></table></figure>

<p>断点命中到 lib\runtime\language\interpreterloop.inl 的 Var Js::InterpreterStackFrame::INTERPRETERLOOPNAME() </p>
<p>单步执行，进入 Interpreter While 循环中的 OpCode Read 的过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INTERPRETER_OPCODE op = ReadByteOp&lt;INTERPRETER_OPCODE&gt;(ip);</span><br></pre></td></tr></table></figure>

<p>ReadByOp 的函数实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    OpCode InterpreterStackFrame::ReadByteOp&lt;OpCode&gt;(<span class="keyword">const</span> byte *&amp; ip</span><br><span class="line">#<span class="keyword">if</span> DBG_DUMP</span><br><span class="line">        , <span class="keyword">bool</span> isExtended <span class="comment">/*= false*/</span></span><br><span class="line">#endif</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DBG || DBG_DUMP</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// For debugging byte-code, store the current offset before the instruction is read:</span></span><br><span class="line">        <span class="comment">// - We convert this to "void *" to encourage the debugger to always display in hex,</span></span><br><span class="line">        <span class="comment">//   which matches the displayed offsets used by ByteCodeDumper.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;DEBUG_currentByteOffset = (<span class="keyword">void</span> *) m_reader.GetCurrentOffset();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        OpCode op = ByteCodeReader::ReadByteOp(ip);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DBG_DUMP</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;scriptContext-&gt;byteCodeHistogram[(<span class="keyword">int</span>)op]++;</span><br><span class="line">        <span class="keyword">if</span> (PHASE_TRACE(Js::InterpreterPhase, <span class="keyword">this</span>-&gt;m_functionBody))</span><br><span class="line">        &#123;</span><br><span class="line">            Output::Print(_u(<span class="string">"%d.%d:Executing %s at offset 0x%X\n"</span>), <span class="keyword">this</span>-&gt;m_functionBody-&gt;GetSourceContextId(), <span class="keyword">this</span>-&gt;m_functionBody-&gt;GetLocalFunctionId(), Js::OpCodeUtil::GetOpCodeName((Js::OpCode)(op+((<span class="keyword">int</span>)isExtended&lt;&lt;<span class="number">8</span>))), DEBUG_currentByteOffset);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> op;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>单步执行到 this-&gt;scriptContext-&gt;byteCodeHistogram[(int)op]++; 当前 c 代码对应的汇编代码为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:004&gt; p</span><br><span class="line">// 这一条指令对应 &quot;this-&gt;scriptContext-&gt;byteCodeHistogram[(int)op]++;&quot;，此时刚好可以看到 op 的值</span><br><span class="line">chakracore!Js::InterpreterStackFrame::ReadByteOp&lt;enum Js::OpCode&gt;+0x3d:</span><br><span class="line">00007ffa`77f7e92d 0fb7442430      movzx   eax,word ptr [rsp+30h] ss:000000fe`71dfd0a0=006b</span><br></pre></td></tr></table></figure>

<p>此时 op 已经被赋值为将要处理的 OpCode 值，为此行代码设置条件断点，拦截 NewScObjArray OpCode</p>
<p>注意:</p>
<p>条件断点中使用寄存器而不是本地变量的方式，原因是实测条件断点中使用本地变量 op 下断点不能触发。</p>
<p>由于本条指令执行时，ax 寄存器刚好存储的就是 OpCode 值，所以改为借助 ax 寄存器下断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0:004&gt; bp . &quot;.if ( @ax == 0n197)&#123;&#125; .else &#123;gc&#125;&quot;</span><br><span class="line"></span><br><span class="line">// 为避免无关的 ProcessUnprofiled 断点频繁命中，临时禁用 ProcessUnprofiled 断点</span><br><span class="line">0:004&gt; bl</span><br><span class="line">     0 e Disable Clear  00007ff7`890c5e90  [K:\edge\op_newscobjarray_type_confusion\chakracore-1.2.0.0\bin\ch\ch.cpp @ 278]     0001 (0001)  0:**** CH!RunScript</span><br><span class="line">     1 e Disable Clear  00007ffb`b8367e30  [K:\edge\op_newscobjarray_type_confusion\chakracore-1.2.0.0\lib\runtime\language\interpreterloop.inl @ 37]     0001 (0001)  0:**** chakracore!Js::InterpreterStackFrame::ProcessUnprofiled</span><br><span class="line">     2 e Disable Clear  00007ffb`b82be92d  [K:\edge\op_newscobjarray_type_confusion\chakracore-1.2.0.0\lib\runtime\language\interpreterstackframe.cpp @ 2285]     0001 (0001)  0:**** chakracore!Js::InterpreterStackFrame::ReadByteOp&lt;enum Js::OpCode&gt;+0x3d &quot;.if ( @ax == 0n197)&#123;&#125; .else &#123;gc&#125;&quot;</span><br><span class="line">0:004&gt; bd 1</span><br><span class="line"></span><br><span class="line">// 此时断下的正是 NewScObjArray OpCode(0xc5)</span><br><span class="line">0:004&gt; g</span><br><span class="line">(338c.360c): C++ EH exception - code e06d7363 (first chance)</span><br><span class="line">(338c.360c): C++ EH exception - code e06d7363 (first chance)</span><br><span class="line">(338c.360c): C++ EH exception - code e06d7363 (first chance)</span><br><span class="line">(338c.360c): C++ EH exception - code e06d7363 (first chance)</span><br><span class="line">chakracore!Js::InterpreterStackFrame::ReadByteOp&lt;enum Js::OpCode&gt;+0x3d:</span><br><span class="line">00007ffb`b82be92d 0fb7442430      movzx   eax,word ptr [rsp+30h] ss:000000f1`528fd1b0=00c5</span><br></pre></td></tr></table></figure>

<h3 id="4-3-NewScObjArray-OpCode-的处理及漏洞触发过程"><a href="#4-3-NewScObjArray-OpCode-的处理及漏洞触发过程" class="headerlink" title="4.3 NewScObjArray OpCode 的处理及漏洞触发过程"></a>4.3 NewScObjArray OpCode 的处理及漏洞触发过程</h3><p>OpCode 各个分支代码都是通过宏生成的，需要一步步展开来看。</p>
<p>Js::InterpreterStackFrame::ReadByteOp<enum js::opcode> 返回之后，回到 lib\runtime\language\interpreterloop.inl （如注释代码位置所示）</enum></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">case</span> INTERPRETER_OPCODE::MediumLayoutPrefix:</span><br><span class="line">            &#123;</span><br><span class="line">                Var yieldValue = <span class="literal">nullptr</span>;</span><br><span class="line">                ip = [<span class="keyword">this</span>, &amp;yieldValue](<span class="keyword">const</span> byte * ip) -&gt; <span class="keyword">const</span> byte *</span><br><span class="line">                &#123;</span><br><span class="line">                    INTERPRETER_OPCODE op = ReadByteOp&lt;INTERPRETER_OPCODE&gt;(ip);</span><br><span class="line">                    <span class="keyword">switch</span> (op) <span class="comment">// NewScObjArray 被 ReadByteOp 读取之后回到这里  </span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">case</span> INTERPRETER_OPCODE::Yield:</span><br><span class="line">                            m_reader.Reg2_Medium(ip);</span><br><span class="line">                            yieldValue = GetReg(GetFunctionBody()-&gt;GetYieldRegister());</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF2_WMS(x, op, func) PROCESS_##x##_COMMON(op, func, _Medium)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF3_WMS(x, op, func, y) PROCESS_##x##_COMMON(op, func, y, _Medium)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF4_WMS(x, op, func, y, t) PROCESS_##x##_COMMON(op, func, y, _Medium, t)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"InterpreterHandler.inl"</span></span></span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="comment">// Help the C++ optimizer by declaring that the cases we</span></span><br><span class="line">                            <span class="comment">// have above are sufficient</span></span><br><span class="line">                            AssertMsg(<span class="literal">false</span>, <span class="string">"dispatch to bad opcode"</span>);</span><br><span class="line">                            __assume(<span class="literal">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> ip;</span><br><span class="line">                &#125;(ip);</span><br></pre></td></tr></table></figure>

<p>继续跟踪，新得到的 NewScObjArray OpCode 进入 switch case 分支，其具体的分支处理代码由宏实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib\runtime\language\interpreterhandler.inl</span></span><br><span class="line">EXDEF3_WMS(CALL,                    NewScObjectSpread,          OP_NewScObjectSpread, CallIExtended)</span><br><span class="line">  DEF3_WMS(CALL,                    NewScObjArray,              OP_NewScObjArray, CallI)</span><br><span class="line">  DEF3_WMS(CALL,                    NewScObjArraySpread,        OP_NewScObjArraySpread, CallIExtended)</span><br></pre></td></tr></table></figure>

<p>上面 switch case 中， DEF3_WMS 的定义为 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF3_WMS(x, op, func, y) PROCESS_##x##_COMMON(op, func, y, _Medium)</span></span><br></pre></td></tr></table></figure>

<p>所以宏展开之后为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PROCESS_CALL_COMMON(NewScObjArray, OP_NewScObjArray, CallI, _Medium)</span><br></pre></td></tr></table></figure>

<p>我们继续看 PROCESS_CALL_COMMON 的定义，也是个宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_CALL_COMMON(name, func, layout, suffix) \</span></span><br><span class="line">    <span class="keyword">case</span> OpCode::name: \</span><br><span class="line">    &#123; \</span><br><span class="line">        PROCESS_READ_LAYOUT(name, layout, suffix); \</span><br><span class="line">        func(playout); \</span><br><span class="line">        <span class="keyword">break</span>; \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>PROCESS_READ_LAYOUT 的定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_READ_LAYOUT(name, layout, suffix) \</span></span><br><span class="line">    CompileAssert(OpCodeInfo&lt;OpCode::name&gt;::Layout == OpLayoutType::layout); \</span><br><span class="line">    <span class="keyword">const</span> unaligned OpLayout#<span class="meta">#layout##suffix * playout = m_reader.layout##suffix(ip); \</span></span><br><span class="line">    Assert((playout != <span class="literal">nullptr</span>) == (Js::OpLayoutType::##layout != Js::OpLayoutType::Empty)); <span class="comment">// Make sure playout is used</span></span><br></pre></td></tr></table></figure>

<p>继续展开</p>
<p>注意这里的展开用到了 ## 连接符，另外一个就是宏在参数替换的时候是以 token 为单位的，在下面的例子中，就是根据 ## 和标点符号将表达式划分成 token 列表，与参数列表项匹配的 token 将会被替换。</p>
<p>在这里我纠结了很久 m_reader.layout##suffix 到底替换不替换，以及 OpLayout##layout##suffix 为什么不写成 OpLayoutlayout##suffix，后来查资料，比较少的资料提到了替换的基本单元是 token，</p>
<p>也就是 token 内部的匹配项是不替换的。</p>
<p>譬如下面的参数中有 layout，而 token 中有 playout，此时不会将 playout 替换为 pCALLI。</p>
<p>参考： <a href="https://www.jianshu.com/p/f8cb57957c03" target="_blank" rel="noopener">https://www.jianshu.com/p/f8cb57957c03</a></p>
<p>参考： <a href="https://zhuanlan.zhihu.com/p/26978356" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26978356</a></p>
<p>全部展开之后的 case 分支为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> OpCode::NewScObjArray: \</span><br><span class="line">    &#123; \</span><br><span class="line">        CompileAssert(OpCodeInfo&lt;OpCode::NewScObjArray&gt;::Layout == OpLayoutType::CallI); \</span><br><span class="line">        <span class="keyword">const</span> unaligned OpLayoutCallI_Medium* playout = m_reader.CallI_Medium(ip); \</span><br><span class="line">        Assert((playout != <span class="literal">nullptr</span>) == (Js::OpLayoutType::CallI != Js::OpLayoutType::Empty)); <span class="comment">// Make sure playout is used</span></span><br><span class="line"></span><br><span class="line">        OP_NewScObjArray(playout); \</span><br><span class="line">        <span class="keyword">break</span>; \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ByteCodeReader::CallI_Medium 是通过宏的方式生成的，一步步的展开之后是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> unaligned OpLayoutCallI_Medium * ByteCodeReader::CallI_Medium() \</span><br><span class="line">    &#123; \</span><br><span class="line">        <span class="keyword">return</span> GetLayout&lt;OpLayoutCallI_Medium&gt;(); \</span><br><span class="line">    &#125; \</span><br><span class="line">    <span class="keyword">const</span> unaligned OpLayoutCallI_Medium * ByteCodeReader::CallI_Medium(<span class="keyword">const</span> byte*&amp; ip) \</span><br><span class="line">    &#123; \</span><br><span class="line">        <span class="keyword">return</span> GetLayout&lt;OpLayoutCallI_Medium&gt;(ip); \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>跟进 CallI_Medium 调用，调用至 GetLayout</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0:004&gt; t</span><br><span class="line">chakracore!Js::ByteCodeReader::CallI_Medium:</span><br><span class="line">00007ffb`c0814570 4889542410      mov     qword ptr [rsp+10h],rdx ss:0000000a`a2bfcae8=0000000aa2bfcb48</span><br><span class="line">0:004&gt; t</span><br><span class="line">chakracore!Js::ByteCodeReader::GetLayout&lt;Js::OpLayoutT_CallI&lt;Js::LayoutSizePolicy&lt;1&gt; &gt; &gt;:</span><br><span class="line">00007ffb`c079e010 4889542410      mov     qword ptr [rsp+10h],rdx ss:0000000a`a2bfcab8=00000125d6bf3900</span><br></pre></td></tr></table></figure>

<p>GetLayout 函数的定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> LayoutType&gt;</span><br><span class="line">    <span class="keyword">const</span> unaligned LayoutType * ByteCodeReader::GetLayout(<span class="keyword">const</span> byte*&amp; ip)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> layoutSize = <span class="keyword">sizeof</span>(LayoutType);</span><br><span class="line"></span><br><span class="line">        AssertMsg((layoutSize &gt; <span class="number">0</span>) &amp;&amp; (layoutSize &lt; <span class="number">100</span>), <span class="string">"Ensure valid layout size"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> byte * layoutData = ip;</span><br><span class="line">        ip += layoutSize;</span><br><span class="line">        m_currentLocation = ip;</span><br><span class="line"></span><br><span class="line">        Assert(m_currentLocation &lt;= m_endLocation);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> unaligned LayoutType *&gt;(layoutData);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此时的 LayoutType 类型定义为： Js::OpLayoutT_CallI&lt;Js::LayoutSizePolicy&lt;1&gt; &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SizePolicy&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OpLayoutT_CallI</span>                // <span class="title">Return</span> = <span class="title">Function</span>(<span class="title">ArgCount</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">typename</span> SizePolicy::ArgSlotType     ArgCount;</span><br><span class="line">        <span class="keyword">typename</span> SizePolicy::RegSlotSType    Return;</span><br><span class="line">        <span class="keyword">typename</span> SizePolicy::RegSlotType     Function;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>LayoutType 的大小为 5 字节</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0:004&gt; dv layoutSize</span><br><span class="line">     layoutSize = 5</span><br></pre></td></tr></table></figure>

<p>GetLayout 函数主要是从当前 ip 的位置读取 sizeof(LayoutType) 字节的数据作为 LayoutType 类型的 layoutData 返回，然后 ip 向后偏移 sizeof(LayoutType) 字节</p>
<p>参考上面的 Case OpNewScObj 分支，从 GetLayout 返回之后，进入 OP_NewScObjArray()，OP_NewScObjArray() 继续调用其具体实现 OP_NewScObjArray_Impl()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">OP_NewScObjArray</span>(<span class="title">const</span> <span class="title">unaligned</span> <span class="title">T</span>* <span class="title">playout</span>) &#123;</span> OP_NewScObjArray_Impl&lt;T, <span class="literal">false</span>&gt;(playout); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">bool</span> <span class="title">Profiled</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">InterpreterStackFrame</span>:</span>:OP_NewScObjArray_Impl(<span class="keyword">const</span> unaligned T* playout, <span class="keyword">const</span> Js::AuxArray&lt;uint32&gt; *spreadIndices)；</span><br></pre></td></tr></table></figure>

<p>OP_NewScObjArray_Impl 的 playout 即为通过 GetLayout 得到的 layoutData</p>
<p>在 OP_NewScObjArray_Impl() 内部，它会调用 ProfilingHelpers::ProfiledNewScObjArray() 以实现对 OP_NewScObjArray 的 Profile 支持。</p>
<p>特别需要注意的是它调用 ProfilingHelpers::ProfiledNewScObjArray() 时的参数，这里的 playout 将通过类型转换至 const unaligned OpLayoutDynamicProfile2<t> * 即 const unaligned OpLayoutDynamicProfile2&lt; Js::OpLayoutT_CallI&lt;Js::LayoutSizePolicy&lt;1&gt; &gt; &gt; *</t></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SetReg(</span><br><span class="line">            (RegSlot)playout-&gt;Return,</span><br><span class="line">            ProfilingHelpers::ProfiledNewScObjArray(</span><br><span class="line">                GetReg(playout-&gt;Function),</span><br><span class="line">                args,</span><br><span class="line">                function,</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> unaligned OpLayoutDynamicProfile2&lt;T&gt; *&gt;(playout)-&gt;profileId,</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> unaligned OpLayoutDynamicProfile2&lt;T&gt; *&gt;(playout)-&gt;profileId2));</span><br></pre></td></tr></table></figure>

<p>下面看一下 OpLayoutDynamicProfile2 结构体和之前的 Js::OpLayoutT_CallI 有何不同</p>
<p>OpLayoutDynamicProfile2 结构体的定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> LayoutType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpLayoutDynamicProfile2</span> :</span> <span class="keyword">public</span> LayoutType</span><br><span class="line">&#123;</span><br><span class="line">    ProfileId profileId;</span><br><span class="line">    ProfileId profileId2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> uint16 ProfileId;</span><br></pre></td></tr></table></figure>

<p>看来两个结构体之间是继承关系。</p>
<p>因为这里的 OpLayoutDynamicProfile2 继承了 LayoutType（Js::OpLayoutT_CallI&lt;Js::LayoutSizePolicy&lt;1&gt; &gt;）结构体，相当于扩充了结构体的大小，在尾部增加了两个结构体成员（uint16）</p>
<p>上面调试中，LayoutType 的大小为 5 字节，此时 OpLayoutDynamicProfile2 为 9 个字节。</p>
<p>而在 InterpreterStackFrame::OP_NewScObjArray_Impl，调用 ProfilingHelpers::ProfiledNewScObjArray 函数传入的参数正是类型转换之后的 profileId 和 profileId2。</p>
<p>我们继续动态跟踪一下调用时的状态及实际的参数 </p>
<p>首先来看一下调用  ProfilingHelpers::ProfiledNewScObjArray 之前 playout 的内存状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0:004&gt; dt playout</span><br><span class="line">Local var @ 0xbdf2bfce48 Type Js::OpLayoutT_CallI&lt;Js::LayoutSizePolicy&lt;1&gt; &gt;*</span><br><span class="line">0x0000024b`c2111c64 </span><br><span class="line">   +0x000 ArgCount         : 0x2 &apos;&apos;</span><br><span class="line">   +0x001 Return           : 0n254</span><br><span class="line">   +0x003 Function         : 0xfe</span><br><span class="line"></span><br><span class="line">// playout 是个指针，需要 poi 查看具体的内存对象</span><br><span class="line"></span><br><span class="line">0:004&gt; db poi(playout)</span><br><span class="line">0000024b`c2111c64  02 fe 00 fe 00 fa fe e9-09 1c 00 e7 fb 06 07 05  ................</span><br><span class="line">0000024b`c2111c74  00 5c 00 0a 5c 01 f4 5c-02 fb 5c 03 f5 5c 04 09  .\..\..\..\..\..</span><br><span class="line">0000024b`c2111c84  f6 05 ff f6 06 00 e9 a8-00 24 00 00 00 00 00 00  .........$......</span><br><span class="line">0000024b`c2111c94  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line">0000024b`c2111ca4  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line">0000024b`c2111cb4  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line">0000024b`c2111cc4  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line">0000024b`c2111cd4  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br></pre></td></tr></table></figure>

<p>注意 playout 内存的前 5 个字节属于 LayoutType（Js::OpLayoutT_CallI&lt;Js::LayoutSizePolicy&lt;1&gt; &gt;），而后面的四个字节 0xfa 0xfe 0xe9 0x09 是 OpLayoutDynamicProfile2 自己派生的两个变量</p>
<p>这里就是问题所在了，我们在理清一下思路。</p>
<p>也就是说，本来我们通过 GetLayout 读取到的 playout 是一个 5 字节的结构体，但是此时类型转换之后， profileId（0xfefa） 和 profileId2(0x09e9) 被作为参数传入 ProfilingHelpers::ProfiledNewScObjArray</p>
<p>下面来跟踪证实一下我们的判断，看一下这两个参数的值</p>
<p>进入 ProfilingHelpers::ProfiledNewScObjArray 函数后，打印两个参数值，发现正是 0xfefa 和 0x09e9</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0:004&gt; </span><br><span class="line">chakracore!Js::ProfilingHelpers::ProfiledNewScObjArray+0x33a:</span><br><span class="line">00007ffb`c10d058a 488b8c2400010000 mov     rcx,qword ptr [rsp+100h] ss:000000bd`f2bfcd20=0000024bc04c3cc0</span><br><span class="line">0:004&gt; dt profileId</span><br><span class="line">Local var @ 0xbdf2bfcd28 Type unsigned short</span><br><span class="line">0xfefa</span><br><span class="line">0:004&gt; dt arrayProfileId</span><br><span class="line">Local var @ 0xbdf2bfcd30 Type unsigned short</span><br><span class="line">0x9e9</span><br></pre></td></tr></table></figure>

<p>我们继续跟踪，ProfilingHelpers::ProfiledNewScObjArray 会将 profileId（0xfefa）参数作为 callSiteId 实参传递给 RecordCallSiteInfo()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">profileInfo-&gt;RecordCallSiteInfo(</span><br><span class="line">           callerFunctionBody,</span><br><span class="line">           profileId,</span><br><span class="line">           calleeFunctionInfo,</span><br><span class="line">           caller,</span><br><span class="line">           args.Info.Count,</span><br><span class="line">           <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0:004&gt; </span><br><span class="line">chakracore!Js::DynamicProfileInfo::RecordCallSiteInfo+0x105:</span><br><span class="line">00007ffb`c0f3b935 488b8424b8000000 mov     rax,qword ptr [rsp+0B8h] ss:000000bd`f2bfcc38=&#123;chakracore!Js::JavascriptArray::EntryInfo::NewInstance (00007ffb`c1f7b418)&#125;</span><br><span class="line">0:004&gt; dt callSiteId</span><br><span class="line">Local var @ 0xbdf2bfcc30 Type unsigned short</span><br><span class="line">0xfefa</span><br></pre></td></tr></table></figure>

<p>而 callSiteId（0xfefa）在 RecordCallSiteInfo 内部会作为数组索引访问 this-&gt;callSiteInfo。那么此时 this-&gt;callSiteInfo 数组的真实长度是多少呢？</p>
<p>这就要看一下 this-&gt;callSiteInfo 的初始化过程了，this-&gt;callSiteInfo 的初始化是在 DynamicProfileInfo::New()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DynamicProfileInfo* DynamicProfileInfo::New(Recycler* recycler, FunctionBody* functionBody, <span class="keyword">bool</span> persistsAcrossScriptContexts)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> totalAlloc = <span class="number">0</span>;</span><br><span class="line">        Allocation batch[] =</span><br><span class="line">        &#123;</span><br><span class="line">            &#123; (uint)offsetof(DynamicProfileInfo, callSiteInfo), functionBody-&gt;GetProfiledCallSiteCount() * <span class="keyword">sizeof</span>(CallSiteInfo) &#125;,</span><br><span class="line">            &#123; (uint)offsetof(DynamicProfileInfo, ldElemInfo), functionBody-&gt;GetProfiledLdElemCount() * <span class="keyword">sizeof</span>(LdElemInfo) &#125;,</span><br><span class="line">            &#123; (uint)offsetof(DynamicProfileInfo, stElemInfo), functionBody-&gt;GetProfiledStElemCount() * <span class="keyword">sizeof</span>(StElemInfo) &#125;,</span><br><span class="line">            &#123; (uint)offsetof(DynamicProfileInfo, arrayCallSiteInfo), functionBody-&gt;GetProfiledArrayCallSiteCount() * <span class="keyword">sizeof</span>(ArrayCallSiteInfo) &#125;,</span><br><span class="line">            &#123; (uint)offsetof(DynamicProfileInfo, fldInfo), functionBody-&gt;GetProfiledFldCount() * <span class="keyword">sizeof</span>(FldInfo) &#125;,</span><br><span class="line">            &#123; (uint)offsetof(DynamicProfileInfo, divideTypeInfo), functionBody-&gt;GetProfiledDivOrRemCount() * <span class="keyword">sizeof</span>(ValueType) &#125;,</span><br><span class="line">            &#123; (uint)offsetof(DynamicProfileInfo, switchTypeInfo), functionBody-&gt;GetProfiledSwitchCount() * <span class="keyword">sizeof</span>(ValueType)&#125;,</span><br><span class="line">            &#123; (uint)offsetof(DynamicProfileInfo, slotInfo), functionBody-&gt;GetProfiledSlotCount() * <span class="keyword">sizeof</span>(ValueType) &#125;,</span><br><span class="line">            &#123; (uint)offsetof(DynamicProfileInfo, parameterInfo), functionBody-&gt;GetProfiledInParamsCount() * <span class="keyword">sizeof</span>(ValueType) &#125;,</span><br><span class="line">            &#123; (uint)offsetof(DynamicProfileInfo, returnTypeInfo), functionBody-&gt;GetProfiledReturnTypeCount() * <span class="keyword">sizeof</span>(ValueType) &#125;,</span><br><span class="line">            &#123; (uint)offsetof(DynamicProfileInfo, loopImplicitCallFlags), (EnableImplicitCallFlags(functionBody) ? (functionBody-&gt;GetLoopCount() * <span class="keyword">sizeof</span>(ImplicitCallFlags)) : <span class="number">0</span>) &#125;,</span><br><span class="line">            &#123; (uint)offsetof(DynamicProfileInfo, loopFlags), functionBody-&gt;GetLoopCount() ? BVFixed::GetAllocSize(functionBody-&gt;GetLoopCount() * LoopFlags::COUNT) : <span class="number">0</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 callSiteInfo 数组的长度是通过 functionBody-&gt;GetProfiledCallSiteCount() 获得的，也就是 FunctionBody 对象的 profiledCallSiteCount 成员变量的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ProfileId <span class="title">GetProfiledCallSiteCount</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;profiledCallSiteCount; &#125;</span><br></pre></td></tr></table></figure>

<p>那么此时在内存中 callSiteInfo 数组的真实长度是多少呢？也就是 functionBody 的 profiledCallSiteCount 成员的值。通过 functionBody 对象我们来看一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:004&gt; dt functionBody profiledCallSiteCount</span><br><span class="line">Local var @ 0xbdf2bfcc28 Type Js::FunctionBody*</span><br><span class="line">0x0000024b`c19b01d0 </span><br><span class="line">   +0x170 profiledCallSiteCount : 2</span><br></pre></td></tr></table></figure>

<p>callSiteInfo 数组的长度是 2</p>
<p>在 callSiteInfo 数组长度是 2 的情况下，竟然尝试以 0xfefa 索引访问它，所以当然是内存越界了。</p>
<p>我们继续通过调试器验证一下这个动态的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// this-&gt;callSiteInfo 的地址为 0x0000024b`c0a100b8</span><br><span class="line">0:004&gt; dt this callSiteInfo</span><br><span class="line">Local var @ 0xbdf2bfcc20 Type Js::DynamicProfileInfo*</span><br><span class="line">0x0000024b`c0a10020 </span><br><span class="line">   +0x008 callSiteInfo : 0x0000024b`c0a100b8 Js::DynamicProfileInfo::CallSiteInfo</span><br><span class="line"></span><br><span class="line">// 查看 js::DynamicProfileInfo::CallSiteInfo 具体的数据结构定义</span><br><span class="line">0:004&gt; dt js::DynamicProfileInfo::CallSiteInfo</span><br><span class="line">chakracore!Js::DynamicProfileInfo::CallSiteInfo</span><br><span class="line">   +0x000 isArgConstant    : Pos 0, 13 Bits</span><br><span class="line">   +0x000 isConstructorCall : Pos 13, 1 Bit</span><br><span class="line">   +0x000 dontInline       : Pos 14, 1 Bit</span><br><span class="line">   +0x000 isPolymorphic    : Pos 15, 1 Bit</span><br><span class="line">   +0x002 returnType       : ValueType</span><br><span class="line">   +0x004 ldFldInlineCacheId : Uint4B</span><br><span class="line">   +0x008 u                : Js::DynamicProfileInfo::CallSiteInfo::&lt;unnamed-type-u&gt;</span><br><span class="line"></span><br><span class="line">// 计算 this-&gt;callSiteInfo 数组项 js::DynamicProfileInfo::CallSiteInfo 结构体的大小，0x10 字节</span><br><span class="line">0:004&gt; ?? sizeof(js::DynamicProfileInfo::CallSiteInfo)</span><br><span class="line">unsigned int64 0x10</span><br><span class="line"></span><br><span class="line">// this-&gt;callSiteInfo[callSiteId] 的地址 0000024b`c0b0f058 第 0xfefa 项的真实地址是多少？ 是 0x0000024b`c0b0f058</span><br><span class="line">0:004&gt; ?? 0x0000024b`c0a100b8+0x10*0xfefa</span><br><span class="line">int64 0n2524378624088</span><br><span class="line">0:004&gt; ? 0x0000024b`c0a100b8+0x10*0xfefa</span><br><span class="line">Evaluate expression: 2524378624088 = 0000024b`c0b0f058</span><br></pre></td></tr></table></figure>

<p>实际调试验证最终崩溃点 if (!callSiteInfo[callSiteId].isPolymorphic) 地址是不是我们上一步自己计算的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0:004&gt; p</span><br><span class="line">chakracore!Js::DynamicProfileInfo::RecordCallSiteInfo+0x158:</span><br><span class="line">00007ffb`c0f3b988 0fb78424b0000000 movzx   eax,word ptr [rsp+0B0h] ss:000000bd`f2bfcc30=fefa</span><br><span class="line"></span><br><span class="line">// 内存访问异常的地址正是 0x0000024b`c0b0f058</span><br><span class="line">0:004&gt; </span><br><span class="line">(3628.1794): Access violation - code c0000005 (first chance)</span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected and handled.</span><br><span class="line">chakracore!Js::DynamicProfileInfo::RecordCallSiteInfo+0x170:</span><br><span class="line">00007ffb`c0f3b9a0 0fb70401        movzx   eax,word ptr [rcx+rax] ds:0000024b`c0b0f058=????</span><br></pre></td></tr></table></figure>

<h3 id="4-4-漏洞的根本原因"><a href="#4-4-漏洞的根本原因" class="headerlink" title="4.4 漏洞的根本原因"></a>4.4 漏洞的根本原因</h3><p>截至目前，我们可以总结一下漏洞的根本原因了</p>
<p>在处理 OP_NewScObjArray Opcode 时，通过 GetLayout 得到的 layoutData 本身是个 5 字节长度的 Js::OpLayoutT_CallI&lt;Js::LayoutSizePolicy&lt;1&gt; &gt; 类型，但是在 ProfilingHelpers::ProfiledNewScObjArray() 内部竟然被转换为 9 字节长度的 const unaligned OpLayoutDynamicProfile2<t> * 类型。</t></p>
<p>转换之后，越界访问得到的错误 profileId 被当作了 DynamicProfileInfo-&gt;callSiteInfo 的数组索引，造成内存越界访问异常。</p>
<p>总结起来，这是个类型混淆导致的越界访问漏洞。</p>
<h2 id="5-补丁分析"><a href="#5-补丁分析" class="headerlink" title="5 补丁分析"></a>5 补丁分析</h2><h3 id="5-1-如何知道该漏洞在哪个版本被修复的"><a href="#5-1-如何知道该漏洞在哪个版本被修复的" class="headerlink" title="5.1 如何知道该漏洞在哪个版本被修复的"></a>5.1 如何知道该漏洞在哪个版本被修复的</h3><p>本来希望可以通过 git log 的 -L 参数实现对函数的追踪，不过实际测试发现不起作用。</p>
<p>最后想到的方法是先通过 git log + grep 碰碰运气，然后手动测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test@test MINGW64 /k/edge/ChakraCore (master)</span><br><span class="line">$ git log --reverse -p v1.2.0.0..HEAD lib/Runtime/Language/InterpreterStackFrame.cpp |grep &quot;OP_NewScObjArray_Impl&quot; -B 120</span><br></pre></td></tr></table></figure>

<p>发现只有一条 commit 涉及 OP_NewScObjArray_Impl，我们来看一下这个 commit</p>
<p>下面来分别编译补丁前后两个版本测试 poc 能否触发</p>
<h4 id="5-2-checkout-打上疑似补丁的版本测试"><a href="#5-2-checkout-打上疑似补丁的版本测试" class="headerlink" title="5.2 checkout 打上疑似补丁的版本测试"></a>5.2 checkout 打上疑似补丁的版本测试</h4><p>从 master 分支回退到上面发现的补丁版本（8bd6826aea01ff1af36f2a83fe00c44799ba80cb），即打上疑似补丁的版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test@test MINGW64 /k/edge/ChakraCore (master)</span><br><span class="line">$ git checkout 8bd6826aea01ff1af36f2a83fe00c44799ba80cb</span><br><span class="line">Checking out files: 100% (1579/1579), done.</span><br><span class="line">Note: checking out &apos;8bd6826aea01ff1af36f2a83fe00c44799ba80cb&apos;.</span><br></pre></td></tr></table></figure>

<p>VS2017 编译，然后测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\test&gt;&quot;K:\edge\ChakraCore\Build\VcBuild\bin\x64_debug\ch.exe&quot; &quot;K:\edge\OP_NewScObjArray_Type_Confusion\poc\pure_js_poc.js&quot;</span><br><span class="line"></span><br><span class="line">C:\Users\test&gt;</span><br></pre></td></tr></table></figure>

<p>发现没有崩溃，证明这个版本该漏洞已经被修复。</p>
<h4 id="5-3-checkout-打上疑似补丁之前版本测试"><a href="#5-3-checkout-打上疑似补丁之前版本测试" class="headerlink" title="5.3 checkout 打上疑似补丁之前版本测试"></a>5.3 checkout 打上疑似补丁之前版本测试</h4><p>再来测试回退到补丁之前版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test@test MINGW64 /k/edge/ChakraCore ((8bd6826ae...))</span><br><span class="line">$ git reset --hard</span><br><span class="line">HEAD is now at 8bd6826ae [CVE-2018-8290] OOB profile read/write - Google, Inc</span><br><span class="line"></span><br><span class="line">test@test MINGW64 /k/edge/ChakraCore ((8bd6826ae...))</span><br><span class="line">$ git checkout 7af07fdfb3cf3ac2b21dd71bf565ab1135e62d4d</span><br></pre></td></tr></table></figure>

<p>VS2017 编译，然后测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\test&gt;</span><br><span class="line">C:\Users\test&gt;&quot;K:\edge\ChakraCore\Build\VcBuild\bin\x64_debug\ch.exe&quot; &quot;K:\edge\OP_NewScObjArray_Type_Confusion\poc\pure_js_poc.js&quot;</span><br><span class="line">FATAL ERROR: ch.exe failed due to exception code c0000005</span><br><span class="line"></span><br><span class="line">C:\Users\test&gt;</span><br></pre></td></tr></table></figure>

<p>发现崩溃了，说明这个 commit 8bd6826aea01ff1af36f2a83fe00c44799ba80cb 正是该漏洞的补丁</p>
<h3 id="5-2-补丁代码分析"><a href="#5-2-补丁代码分析" class="headerlink" title="5.2 补丁代码分析"></a>5.2 补丁代码分析</h3><p>补丁代码中，OP_NewScObjArray OpCode 的处理函数 OP_NewScObjArray_Impl 不再实现具体的逻辑，改为调用 OP_NewScObject_Impl。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/lib/Runtime/Language/InterpreterStackFrame.h b/lib/Runtime/Language/InterpreterStackFrame.h</span><br><span class="line">index 8ebc7c13c..a3ad7504e 100644</span><br><span class="line"><span class="comment">--- a/lib/Runtime/Language/InterpreterStackFrame.h</span></span><br><span class="line"><span class="comment">+++ b/lib/Runtime/Language/InterpreterStackFrame.h</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-        template &lt;class T, bool Profiled&gt; void OP_NewScObjArray_Impl(const unaligned T* playout, const Js::AuxArray&lt;uint32&gt; *spreadIndices = nullptr);</span></span><br><span class="line"><span class="addition">+        template &lt;class T, bool Profiled, bool ICIndex&gt; void OP_ProfiledNewScObject_Impl(const unaligned T* playout, InlineCacheIndex inlineCacheIndex = Js::Constants::NoInlineCacheIndex, const Js::AuxArray&lt;uint32&gt; *spreadIndices = nullptr) &#123; OP_NewScObject_Impl&lt;T, Profiled, ICIndex&gt;(playout, inlineCacheIndex, spreadIndices); &#125;</span></span><br><span class="line"><span class="addition">+        template &lt;class T, bool Profiled&gt; void OP_NewScObjArray_Impl(const unaligned T* playout, const Js::AuxArray&lt;uint32&gt; *spreadIndices = nullptr) &#123; OP_NewScObject_Impl&lt;T, Profiled, false&gt;(playout, Js::Constants::NoInlineCacheIndex, spreadIndices); &#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">bool</span> <span class="title">Profiled</span>, <span class="title">bool</span> <span class="title">ICIndex</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">InterpreterStackFrame</span>:</span>:OP_NewScObject_Impl(<span class="keyword">const</span> unaligned T* playout, InlineCacheIndex inlineCacheIndex, <span class="keyword">const</span> Js::AuxArray&lt;uint32&gt; *spreadIndices)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ICIndex)</span><br><span class="line">        &#123;</span><br><span class="line">            Assert(inlineCacheIndex != Js::Constants::NoInlineCacheIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        Var newVarInstance =</span><br><span class="line">#<span class="keyword">if</span> ENABLE_PROFILE_INFO</span><br><span class="line">            Profiled ?</span><br><span class="line">            ProfiledNewScObject_Helper(</span><br><span class="line">                GetReg(playout-&gt;Function),</span><br><span class="line">                playout-&gt;ArgCount,</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> unaligned OpLayoutDynamicProfile&lt;T&gt; *&gt;(playout)-&gt;profileId,</span><br><span class="line">                inlineCacheIndex,</span><br><span class="line">                spreadIndices) :</span><br><span class="line">#endif</span><br><span class="line">            NewScObject_Helper(GetReg(playout-&gt;Function), playout-&gt;ArgCount, spreadIndices);</span><br><span class="line">        SetReg((RegSlot)playout-&gt;Return, newVarInstance);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当进入到 OP_NewScObject_Impl 函数的时候，可以发现此时传入的 playout 内存的数据与补丁之前是一致的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0:004&gt; p</span><br><span class="line">chakracore!Js::InterpreterStackFrame::OP_NewScObject_Impl&lt;Js::OpLayoutT_CallI&lt;Js::LayoutSizePolicy&lt;1&gt; &gt;,0,0&gt;+0x18:</span><br><span class="line">00007ffd`cfc16b88 33c0            xor     eax,eax</span><br><span class="line">0:004&gt; dt playout</span><br><span class="line">Local var @ 0x4da20fc468 Type Js::OpLayoutT_CallI&lt;Js::LayoutSizePolicy&lt;1&gt; &gt;*</span><br><span class="line">0x000001c3`1a7a4c9b </span><br><span class="line">   +0x000 ArgCount         : 0x2 &apos;&apos;</span><br><span class="line">   +0x001 Return           : 0n254</span><br><span class="line">   +0x003 Function         : 0xfe</span><br><span class="line">0:004&gt; db poi(playout)</span><br><span class="line">000001c3`1a7a4c9b  02 fe 00 fe 00 fa fe e9-09 24 00 e7 fb 06 07 05  .........$......</span><br><span class="line">000001c3`1a7a4cab  00 5b 00 0a 5c 01 f4 08-00 5c 02 fb 08 00 5c 03  .[..\....\....\.</span><br><span class="line">000001c3`1a7a4cbb  f5 08 00 5c 04 09 08 00-ee 05 ff f6 08 00 e9 a7  ...\............</span><br><span class="line">000001c3`1a7a4ccb  00 24 00 00 00 00 00 00-00 00 00 00 00 00 00 00  .$..............</span><br><span class="line">000001c3`1a7a4cdb  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line">000001c3`1a7a4ceb  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line">000001c3`1a7a4cfb  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br><span class="line">000001c3`1a7a4d0b  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span><br></pre></td></tr></table></figure>

<p>接下来，因为 OP_NewScObjArray_Impl 调用 OP_NewScObject_Impl 时传入的模板参数 Profiled 为 false。所以会调用 NewScObject_Helper 创建 newInstance 赋值给 playout-&gt;Return 寄存器。</p>
<p>注意在这个 OP_NewScObjArray 的处理过程中，已经不像补丁之前的代码存在类型转换，所以漏洞也就不再存在了。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">     template &lt;class T, bool Profiled&gt;</span><br><span class="line"><span class="deletion">-    void InterpreterStackFrame::OP_NewScObjArray_Impl(const unaligned T* playout, const Js::AuxArray&lt;uint32&gt; *spreadIndices)</span></span><br><span class="line"><span class="addition">+    void InterpreterStackFrame::OP_ProfiledNewScObjArray_Impl(const unaligned T* playout, const Js::AuxArray&lt;uint32&gt; *spreadIndices)</span></span><br><span class="line">     &#123;</span><br><span class="line">         // Always profile this operation when auto-profiling so that array type changes are tracked</span><br><span class="line"> #if ENABLE_PROFILE_INFO</span><br><span class="line">@@ -6212,7 +6222,7 @@ namespace Js</span><br><span class="line">         Assert(!Profiled);</span><br><span class="line"> #endif</span><br><span class="line">         &#123;</span><br><span class="line"><span class="deletion">-            OP_NewScObject_Impl&lt;T, Profiled, false&gt;(playout, Js::Constants::NoInlineCacheIndex, spreadIndices);</span></span><br><span class="line"><span class="addition">+            OP_NewScObjArray_Impl&lt;T, Profiled&gt;(playout, spreadIndices);</span></span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<p>总结一下补丁，补丁后的版本，OP_NewScObjArray_Impl 仅仅是 OP_NewScObject_Impl 的封装，不再有之前复杂的判断和逻辑，不再有类型转换，所以漏洞也就被修复了。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://blogs.360.cn/post/Microsoft%20Edge%20Chakra%20OP_NewScObjArray%20Type%20Confusion%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8.html" target="_blank" rel="noopener">Microsoft Edge Chakra OP_NewScObjArray Type Confusion 远程代码执行漏洞分析与利用</a></li>
<li><a href="https://github.com/Microsoft/ChakraCore" target="_blank" rel="noopener">https://github.com/Microsoft/ChakraCore</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rekken.github.io/2019/03/31/Analysis-of-Microsoft-Edge-Chakra-OP-NewScObjArray-Type-Confusion-Vulnerability/" data-id="cjz1ugcsx000313rj9dyhlonv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2017/05/30/Windows-Logical-EoP-Workshop-Writeup/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Windows Logical EoP Workshop Writeup</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/31/Analysis-of-Microsoft-Edge-Chakra-OP-NewScObjArray-Type-Confusion-Vulnerability/">Microsoft Edge Chakra OP_NewScObjArray 类型混淆漏洞分析笔记</a>
          </li>
        
          <li>
            <a href="/2017/05/30/Windows-Logical-EoP-Workshop-Writeup/">Windows Logical EoP Workshop Writeup</a>
          </li>
        
          <li>
            <a href="/2017/01/01/hello-hexo/">Hello Hexo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 rekken<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>